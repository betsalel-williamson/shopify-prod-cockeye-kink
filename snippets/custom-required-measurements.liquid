{% comment %}
  Custom Required Measurements Snippet
  Configuration: Define measurement and category groupings using reusable strings.
  Group strings are composed once and reused across categories to keep the data DRY.
{% endcomment %}

{%- assign upper_torso = 'Chest|Shoulders|Torso' | split: '|' -%}
{%- assign stomach_array = 'Stomach' | split: '|' -%}
{%- assign bicep_array = 'Bicep' | split: '|' -%}
{%- assign neck_array = 'Neck' | split: '|' -%}
{%- assign waist_array = 'Waist' | split: '|' -%}
{%- assign lower_leg_chain = 'Upper Thigh|Lower Thigh|Knee|Calf|Ankle' | split: '|' -%}
{%- assign butt_array = 'Butt|Butt Rise' | split: '|' -%}
{%- assign inseam_crotch_array = 'Inseam|Crotch' | split: '|' -%}
{%- assign hips_array = 'Hips' | split: '|' -%}

{%- assign measurement_names = neck_array
  | concat: upper_torso
  | concat: stomach_array
  | concat: waist_array
  | concat: butt_array
  | concat: lower_leg_chain
  | concat: inseam_crotch_array
  | concat: bicep_array
  | concat: hips_array
  | uniq
-%}
{%- assign categories_order = 'Deluxe Harness|Standard Harness|Suspender Harness|Dogtag/Pigtag|Chaps|Shirt|Pants|Suspenders|Other' | split: '|' -%}

{%- assign harness_categories = 'Deluxe Harness|Standard Harness|Suspender Harness' | split: '|' -%}
{%- assign notes_categories = 'Dogtag/Pigtag|Chaps|Shirt|Pants|Suspenders|Other' | split: '|' -%}

{%- assign harness_required = neck_array | concat: upper_torso | concat: waist_array -%}
{%- assign suspenders_required = 'Chest|Shoulders|Waist' | split: '|' -%}
{%- assign shirt_required = upper_torso | concat: stomach_array | concat: bicep_array -%}
{%- assign chaps_required = waist_array | concat: lower_leg_chain -%}
{%- assign pants_required = waist_array | concat: butt_array | concat: lower_leg_chain | concat: inseam_crotch_array -%}

{%- assign empty_measurement_list = measurement_names | slice: 0, 0 -%}
{%- assign dogtag_optional = neck_array -%}
{%- assign hips_optional = hips_array -%}
{%- assign other_optional = measurement_names -%}

{%- assign leather_colors = 'Black|White|Red|Blue|Green|Yellow|Orange|Purple' | split: '|' -%}
{%- assign front_plate_options = 'Bear Paw|Puppy Paw|Fist Image|Pig Image|Boot Image|Biohazard Symbol|Cigar Man' | split: '|' -%}
{%- assign back_plate_extra = 'Wesco Boot|Watersports|Happy Puppy' | split: '|' -%}
{%- assign back_plate_options = front_plate_options | concat: back_plate_extra -%}
{%- assign left_front_plates = front_plate_options -%}
{%- assign right_front_plates = front_plate_options -%}
{%- assign back_plates = back_plate_options -%}
{%- assign long_sliders = 'None|Brass|Steel' | split: '|' -%}

{%- liquid
  comment
    Configuration source of truth lives in the JSON block above.
    Liquid assigns only order metadata and banner defaults here.
  endcomment

  assign order_tag_name = '_custom'
  assign order_tag_value = 'custom'
  assign banner_text = 'Order has not been submitted yet'

  comment
    Show banner as long as order is in cart and not submitted:
    - On product page: always show (order hasn't been added yet)
    - On cart page: show if cart has items (order is in cart)
    - On checkout/thank you pages: hide (order has been submitted)
  endcomment
  assign banner_enabled = true
  if template.name == 'cart'
    if cart.item_count > 0
      assign banner_enabled = true
    else
      assign banner_enabled = false
    endif
  endif
  if template.name == 'checkout'
    assign banner_enabled = false
  endif
  if request.page_type == 'checkout'
    assign banner_enabled = false
  endif
-%}

<style>
  .order-status-banner {
    background-color: #fff3cd;
    border: 2px solid #ffc107;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 20px;
    font-weight: bold;
    color: #856404;
    text-align: center;
  }

  .unit-toggle-container {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    padding: 8px 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
  }

  .unit-toggle-label {
    font-weight: bold;
    margin-right: 8px;
  }

  .unit-toggle-buttons {
    display: flex;
    gap: 8px;
  }

  .unit-toggle-button {
    padding: 6px 16px;
    border: 2px solid #ccc;
    border-radius: 6px;
    background-color: white;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
  }

  .unit-toggle-button.active {
    background-color: #444;
    color: #fff;
    border-color: #444;
  }

  .measurement-input {
    font-weight: bold;
    color: black;
    width: 6em;
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
  }

  .measurements-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;
    margin-bottom: 16px;
  }

  .measurements-group label {
    display: block;
    margin-bottom: 4px;
    font-weight: bold;
  }

  .measurement-field {
    display: none;
  }

  .measurement-field.active {
    display: block;
  }

  .options-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 16px;
  }

  .option-button {
    background-color: #eee;
    border: 2px solid #ccc;
    border-radius: 8px;
    padding: 10px 18px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .option-button.selected {
    background-color: #444;
    color: #fff;
  }

  .conditional-section {
    display: none;
    margin-top: 16px;
    padding: 10px;
    background-color: #f9f9f9;
    border-radius: 8px;
  }

  .conditional-section.active {
    display: block;
  }

  .conditional-section label {
    display: block;
    margin-top: 12px;
    margin-bottom: 4px;
    font-weight: bold;
  }

  .conditional-section label:first-child {
    margin-top: 0;
  }

  .conditional-section select {
    display: block;
    width: 100%;
    margin-bottom: 8px;
  }

  .conditional-section .custom-text {
    display: block;
    width: 100%;
    margin-top: 8px;
    margin-bottom: 8px;
  }

  .custom-text {
    margin-top: 8px;
    display: none;
  }

  .custom-toggle-button {
    display: inline-block;
    margin-top: 12px;
    background-color: #ccc;
    padding: 8px 14px;
    font-weight: bold;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .custom-toggle-button:hover {
    background-color: #aaa;
  }
</style>

{%- comment -%} Order Status Banner - Displayed as long as order is in cart and not submitted {%- endcomment -%}
{%- if banner_enabled -%}
  <div class="order-status-banner" id="order-status-banner">
    {{ banner_text }}
  </div>
{%- endif -%}

{%- comment -%} Category Selection Buttons {%- endcomment -%}
<div class="options-group" id="optionButtons">
  {%- for category in categories_order -%}
    {%- assign required_list = empty_measurement_list -%}
    {%- assign optional_list = empty_measurement_list -%}
    {%- if category == 'Deluxe Harness' or category == 'Standard Harness' -%}
      {%- assign required_list = harness_required -%}
    {%- elsif category == 'Suspender Harness' -%}
      {%- assign required_list = harness_required -%}
    {%- elsif category == 'Dogtag/Pigtag' -%}
      {%- assign optional_list = dogtag_optional -%}
    {%- elsif category == 'Chaps' -%}
      {%- assign required_list = chaps_required -%}
      {%- assign optional_list = hips_optional -%}
    {%- elsif category == 'Shirt' -%}
      {%- assign required_list = shirt_required -%}
    {%- elsif category == 'Pants' -%}
      {%- assign required_list = pants_required -%}
      {%- assign optional_list = hips_optional -%}
    {%- elsif category == 'Suspenders' -%}
      {%- assign required_list = suspenders_required -%}
    {%- elsif category == 'Other' -%}
      {%- assign optional_list = other_optional -%}
    {%- endif -%}

    {%- assign required_string = required_list | join: '|' -%}
    {%- assign optional_string = optional_list | join: '|' -%}

    <button
      type="button"
      class="option-button"
      data-index="{{ forloop.index0 }}"
      data-label="{{ category }}"
      data-required="{{ required_string }}"
      data-optional="{{ optional_string }}"
      data-show-harness="{% if harness_categories contains category %}true{% else %}false{% endif %}"
      data-show-notes="{% if notes_categories contains category %}true{% else %}false{% endif %}"
    >
      {{ category }}
    </button>
  {%- endfor -%}
</div>

{%- comment -%} Unit of Measure - First property to indicate measurement unit used {%- endcomment -%}
<input
  type="hidden"
  id="unitOfMeasure"
  name="properties[Unit of Measure]"
  value="Measured in Inches"
  form="product-form-{{ section.id }}"
>

<input type="hidden" id="selectedOption" name="properties[Selected Option]" form="product-form-{{ section.id }}">

{%- comment -%} Custom Order Tagging {%- endcomment -%}
<input
  type="hidden"
  name="properties[{{ order_tag_name }}]"
  value="{{ order_tag_value }}"
  form="product-form-{{ section.id }}"
>

{%- comment -%} Unit Toggle {%- endcomment -%}
<div class="unit-toggle-container">
  <span class="unit-toggle-label">Unit:</span>
  <div class="unit-toggle-buttons">
    <button type="button" class="unit-toggle-button active" data-unit="in">Inches</button>
    <button type="button" class="unit-toggle-button" data-unit="cm">Centimeters</button>
  </div>
</div>

{%- comment -%} Measurement Fields {%- endcomment -%}
<div class="measurements-group" id="measurementsGroup">
  {%- for meas_name in measurement_names -%}
    {%- assign handle = meas_name | handleize -%}
    <div
      class="measurement-field"
      id="measurement-{{ handle }}"
      data-measurement="{{ meas_name }}"
    >
      <label for="{{ handle }}-in">{{ meas_name }}</label>
      <input
        type="number"
        inputmode="decimal"
        autocomplete="off"
        id="{{ handle }}-in"
        name="properties[{{ meas_name }} (in)]"
        form="product-form-{{ section.id }}"
        class="measurement-input measurement-in"
        data-measurement="{{ meas_name }}"
        placeholder="0.000"
      >
      <input
        type="number"
        inputmode="decimal"
        autocomplete="off"
        id="{{ handle }}-cm"
        name="properties[{{ meas_name }} (cm)]"
        form="product-form-{{ section.id }}"
        class="measurement-input measurement-cm"
        data-measurement="{{ meas_name }}"
        placeholder="0.000"
        style="display: none;"
      >
    </div>
  {%- endfor -%}
</div>

{%- comment -%} Harness Details Section {%- endcomment -%}
<div class="conditional-section" id="harness-details">
  <label>Leather Color</label>
  <select name="properties[Leather Color]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for color in leather_colors -%}
      <option>{{ color }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Leather Color - Text]"
    class="custom-text"
    placeholder="Enter custom color"
    form="product-form-{{ section.id }}"
  >

  <label>Left Front Plate</label>
  <select name="properties[Left Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in left_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Left Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Right Front Plate</label>
  <select name="properties[Right Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in right_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Right Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Back Plate</label>
  <select name="properties[Back Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in back_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Back Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Long Sliders</label>
  <select name="properties[Long Sliders]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for slider in long_sliders -%}
      <option>{{ slider }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Long Sliders - Text]"
    class="custom-text"
    placeholder="Enter custom sliders"
    form="product-form-{{ section.id }}"
  >

  <div>
    <button type="button" class="custom-toggle-button" onclick="toggleCustomFields()">
      Don't see a color listed? Click here
    </button>
  </div>
</div>

{%- comment -%} Notes Section {%- endcomment -%}
<div class="conditional-section" id="notes-section">
  <label>Notes</label>
  <textarea
    name="properties[Notes]"
    placeholder="Enter your notes here"
    form="product-form-{{ section.id }}"
  ></textarea>
  <label>Event (Optional)</label>
  <textarea
    name="properties[Event (Optional)]"
    placeholder="Event name or details"
    form="product-form-{{ section.id }}"
  ></textarea>
</div>

<script>
  (function () {
    'use strict';

    const optionButtons = Array.from(document.querySelectorAll('.option-button'));
    const measurementFields = Array.from(document.querySelectorAll('.measurement-field'));
    const measurementNames = measurementFields.map((field) => field.dataset.measurement);

    const categoryConfigs = {};
    const harnessDetailCategories = [];
    const notesSectionCategories = [];

    optionButtons.forEach((button) => {
      const categoryName = button.dataset.label;
      const requiredList = (button.dataset.required || '').split('|').filter(Boolean);
      const optionalList = (button.dataset.optional || '').split('|').filter(Boolean);
      categoryConfigs[categoryName] = {
        required: requiredList,
        optional: optionalList,
      };
      if (button.dataset.showHarness === 'true') {
        harnessDetailCategories.push(categoryName);
      }
      if (button.dataset.showNotes === 'true') {
        notesSectionCategories.push(categoryName);
      }
    });

    const measurements = {};
    measurementNames.forEach((measName) => {
      const categoryInfo = {};
      Object.entries(categoryConfigs).forEach(([categoryName, categoryConfig]) => {
        if (categoryConfig.required.includes(measName)) {
          categoryInfo[categoryName] = { included: true, required: true };
        } else if (categoryConfig.optional.includes(measName)) {
          categoryInfo[categoryName] = { included: true, required: false };
        }
      });
      measurements[measName] = { categories: categoryInfo };
    });

    const config = {
      measurements,
      categories: {
        harness_details: harnessDetailCategories,
        notes_section: notesSectionCategories,
      },
    };

    const INCH_TO_CM = 2.54;
    const CM_TO_INCH = 1 / 2.54;
    const PRECISION = 3;

    let currentUnit = 'in';
    let selectedCategory = null;
    const measurementValues = new Map();
    let isSyncingValues = false;

    const measurementInputs = document.querySelectorAll('.measurement-input');
    const selectedInput = document.getElementById('selectedOption');
    const harnessSection = document.getElementById('harness-details');
    const notesSection = document.getElementById('notes-section');
    const unitToggleButtons = document.querySelectorAll('.unit-toggle-button');

    const productFormSelectors = [
      '#product-form-{{ section.id }}',
      'form[action*="/cart/add"]',
      'form[id^="product-form"]',
    ];
    let productForm = null;
    for (const selector of productFormSelectors) {
      const formCandidate = document.querySelector(selector);
      if (formCandidate) {
        productForm = formCandidate;
        break;
      }
    }

    const unitOfMeasureInput = document.getElementById('unitOfMeasure');
    const harnessSelects = document.querySelectorAll('#harness-details select');
    const harnessCustomTexts = document.querySelectorAll('#harness-details .custom-text');

    const buttonId = 'ProductSubmitButton-{{ section.id }}';
    let addToCartButton = null;
    let addToCartButtonWarningLogged = false;

    function resolveAddToCartButton() {
      if (addToCartButton && document.body.contains(addToCartButton)) {
        return addToCartButton;
      }

      const buttonSelectors = [
        `#${buttonId}`,
        `#product-form-{{ section.id }} button[type="submit"]`,
        `#product-form-{{ section.id }} button[name="add"]`,
        'form[action*="/cart/add"] button[type="submit"]',
        'form[action*="/cart/add"] button[name="add"]',
        'button[name="add"][type="submit"]',
      ];

      for (const selector of buttonSelectors) {
        const candidate = document.querySelector(selector);
        if (candidate) {
          addToCartButton = candidate;
          return addToCartButton;
        }
      }

      if (!addToCartButtonWarningLogged) {
        console.warn('Could not find add to cart button with ID:', buttonId);
        addToCartButtonWarningLogged = true;
      }

      return null;
    }

    function formatValue(value) {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return '';
      }
      return Number(value).toFixed(PRECISION);
    }

    function parseValue(raw) {
      if (typeof raw !== 'string') return NaN;
      const trimmed = raw.trim();
      if (trimmed === '') return NaN;
      const parsed = Number(trimmed);
      return Number.isFinite(parsed) ? parsed : NaN;
    }

    function hasValidNumber(input) {
      if (!input) return false;
      return Number.isFinite(parseValue(input.value));
    }

    function clearMeasurementField(field) {
      const inInput = field.querySelector('.measurement-in');
      const cmInput = field.querySelector('.measurement-cm');
      if (inInput) inInput.value = '';
      if (cmInput) cmInput.value = '';
      measurementValues.delete(field.dataset.measurement);
    }

    function updateMeasurementVisibility() {
      measurementFields.forEach((field) => {
        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');
        if (!inInput || !cmInput) return;
        if (currentUnit === 'in') {
          inInput.style.display = 'block';
          cmInput.style.display = 'none';
        } else {
          inInput.style.display = 'none';
          cmInput.style.display = 'block';
        }
      });
    }

    function syncMeasurementValues(measName, sourceUnit, numericValue) {
      const field = document.querySelector(`.measurement-field[data-measurement="${measName}"]`);
      if (!field) return;
      const inInput = field.querySelector('.measurement-in');
      const cmInput = field.querySelector('.measurement-cm');
      if (!inInput || !cmInput) return;

      if (isSyncingValues) return;
      isSyncingValues = true;

      if (sourceUnit === 'in') {
        if (inInput.value !== formatValue(numericValue)) {
          inInput.value = formatValue(numericValue);
        }
        const converted = numericValue * INCH_TO_CM;
        cmInput.value = formatValue(converted);
        measurementValues.set(measName, { in: numericValue, cm: converted });
      } else {
        if (cmInput.value !== formatValue(numericValue)) {
          cmInput.value = formatValue(numericValue);
        }
        const converted = numericValue * CM_TO_INCH;
        inInput.value = formatValue(converted);
        measurementValues.set(measName, { in: converted, cm: numericValue });
      }

      isSyncingValues = false;
    }

    function updateMeasurementsForCategory(category) {
      measurementFields.forEach((field) => {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];
        const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[category] : null;

        if (categoryInfo && categoryInfo.included) {
          field.classList.add('active');
        } else {
          field.classList.remove('active');
          clearMeasurementField(field);
        }
      });
    }

    function validateRequiredFields() {
      if (!selectedCategory || !config.measurements) return false;

      const activeFields = document.querySelectorAll('.measurement-field.active');
      for (const field of activeFields) {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];
        if (!measConfig) continue;

        const categoryInfo = measConfig.categories ? measConfig.categories[selectedCategory] : null;
        if (!categoryInfo || !categoryInfo.required) continue;

        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');
        const hasValue = hasValidNumber(inInput) || hasValidNumber(cmInput);
        if (!hasValue) {
          return false;
        }
      }

      if (harnessSection && harnessSection.classList.contains('active')) {
        const harnessFields = [
          'properties[Leather Color]',
          'properties[Left Front Plate]',
          'properties[Right Front Plate]',
          'properties[Back Plate]',
          'properties[Long Sliders]',
        ];

        for (const fieldName of harnessFields) {
          const select = document.querySelector(`select[name="${fieldName}"]`);
          if (!select) continue;
          const selectedOption = select.options[select.selectedIndex];
          const hasSelectValue =
            selectedOption &&
            selectedOption.value !== '' &&
            selectedOption.value !== null &&
            selectedOption.value !== 'Select one';

          const customTextName = fieldName.replace(']', ' - Text]');
          const customText = document.querySelector(`input[name="${customTextName}"]`);
          const hasCustomText = customText && customText.value && customText.value.trim() !== '';

          if (!hasSelectValue && !hasCustomText) {
            return false;
          }
        }
      }

      return true;
    }

    function updateAddToCartButton() {
      const button = resolveAddToCartButton();
      if (!button) return;

      const isValid = validateRequiredFields();
      if (!isValid) {
        button.disabled = true;
        button.style.opacity = '0.5';
        button.setAttribute('disabled', 'disabled');
        button.setAttribute('aria-disabled', 'true');
        button.title = 'Please select a category and fill all required measurements';
      } else {
        button.disabled = false;
        button.style.opacity = '1';
        button.removeAttribute('disabled');
        button.removeAttribute('aria-disabled');
        button.removeAttribute('title');
      }
    }

    function updateSectionVisibility(category) {
      if (harnessSection) {
        const showHarness =
          config.categories && config.categories.harness_details
            ? config.categories.harness_details.includes(category)
            : false;
        harnessSection.classList.toggle('active', showHarness);
      }
      if (notesSection) {
        const showNotes =
          config.categories && config.categories.notes_section
            ? config.categories.notes_section.includes(category) || category === 'Other'
            : category === 'Other';
        notesSection.classList.toggle('active', showNotes);
      }

      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });
    }

    function updateMeasurementOnUnitChange() {
      const activeFields = document.querySelectorAll('.measurement-field.active');
      activeFields.forEach((field) => {
        const measName = field.dataset.measurement;
        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');

        if (!inInput || !cmInput) return;

        if (currentUnit === 'in') {
          const cmValue = parseValue(cmInput.value);
          if (Number.isFinite(cmValue)) {
            syncMeasurementValues(measName, 'cm', cmValue);
          }
        } else {
          const inValue = parseValue(inInput.value);
          if (Number.isFinite(inValue)) {
            syncMeasurementValues(measName, 'in', inValue);
          }
        }
      });

      updateMeasurementVisibility();
      updateAddToCartButton();
    }

    function initialize() {
      if (unitOfMeasureInput) {
        unitOfMeasureInput.value = 'Measured in Inches';
      }

      optionButtons.forEach((btn) => btn.classList.remove('selected'));
      if (selectedInput) selectedInput.value = '';
      selectedCategory = null;

      if (harnessSection) harnessSection.classList.remove('active');
      if (notesSection) notesSection.classList.remove('active');

      measurementFields.forEach((field) => {
        clearMeasurementField(field);
        field.classList.remove('active');
      });

      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });

      currentUnit = 'in';
      unitToggleButtons.forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.unit === 'in');
      });
      updateMeasurementVisibility();

      measurementValues.clear();

      if (optionButtons.length > 0) {
        const firstButton = optionButtons[0];
        firstButton.classList.add('selected');
        selectedCategory = firstButton.dataset.label;
        if (selectedInput) selectedInput.value = selectedCategory;
        updateSectionVisibility(selectedCategory);
        updateMeasurementsForCategory(selectedCategory);
      }

      const button = resolveAddToCartButton();
      if (button) {
        button.disabled = true;
        button.style.opacity = '0.5';
      }
      updateAddToCartButton();
    }

    function updateBannerVisibility() {
      const banner = document.getElementById('order-status-banner');
      if (!banner) return;

      if (
        window.location.pathname.includes('/checkouts/') ||
        window.location.pathname.includes('/thank-you') ||
        window.location.pathname.includes('/checkout')
      ) {
        banner.style.display = 'none';
        return;
      }

      if (window.location.pathname.includes('/products/')) {
        banner.style.display = 'block';
        return;
      }

      if (window.location.pathname.includes('/cart')) {
        fetch('/cart.js')
          .then((response) => response.json())
          .then((cart) => {
            banner.style.display = cart.item_count > 0 ? 'block' : 'none';
          })
          .catch(() => {
            banner.style.display = 'block';
          });
      }
    }

    optionButtons.forEach((button) => {
      button.addEventListener('click', function () {
        optionButtons.forEach((btn) => btn.classList.remove('selected'));
        this.classList.add('selected');
        selectedCategory = this.dataset.label;
        if (selectedInput) selectedInput.value = selectedCategory;

        updateSectionVisibility(selectedCategory);
        updateMeasurementsForCategory(selectedCategory);
        updateMeasurementOnUnitChange();
        updateAddToCartButton();
      });
    });

    unitToggleButtons.forEach((button) => {
      button.addEventListener('click', function () {
        currentUnit = this.dataset.unit;
        unitToggleButtons.forEach((btn) => {
          btn.classList.toggle('active', btn.dataset.unit === currentUnit);
        });

        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        updateMeasurementOnUnitChange();
      });
    });

    measurementInputs.forEach((input) => {
      input.addEventListener('input', function () {
        const field = this.closest('.measurement-field');
        if (!field) return;
        const measName = field.dataset.measurement;
        const unit = this.classList.contains('measurement-in') ? 'in' : 'cm';
        const numericValue = parseValue(this.value);

        if (Number.isFinite(numericValue)) {
          syncMeasurementValues(measName, unit, numericValue);
        } else if (!isSyncingValues) {
          const targetInput =
            unit === 'in' ? field.querySelector('.measurement-cm') : field.querySelector('.measurement-in');
          if (targetInput) {
            targetInput.value = '';
          }
          measurementValues.delete(measName);
        }

        updateAddToCartButton();
      });
    });

    harnessSelects.forEach((select) => {
      select.addEventListener('change', updateAddToCartButton);
    });

    harnessCustomTexts.forEach((input) => {
      input.addEventListener('input', updateAddToCartButton);
    });

    if (productForm) {
      productForm.addEventListener('submit', function (event) {
        if (!validateRequiredFields()) {
          event.preventDefault();
          alert('Please select a category and fill all required measurements.');
          return false;
        }

        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        document.querySelectorAll('.measurement-field.active').forEach((field) => {
          const measName = field.dataset.measurement;
          const inInput = field.querySelector('.measurement-in');
          const cmInput = field.querySelector('.measurement-cm');
          const inValue = parseValue(inInput ? inInput.value : '');
          const cmValue = parseValue(cmInput ? cmInput.value : '');

          if (Number.isFinite(inValue) && !Number.isFinite(cmValue)) {
            syncMeasurementValues(measName, 'in', inValue);
          } else if (Number.isFinite(cmValue) && !Number.isFinite(inValue)) {
            syncMeasurementValues(measName, 'cm', cmValue);
          }
        });

        if (selectedCategory && config.measurements) {
          const measurementInputsForSubmit = this.querySelectorAll('input[name^="properties["]');
          measurementInputsForSubmit.forEach((input) => {
            const name = input.getAttribute('name');
            if (!name || (!name.includes('(in)') && !name.includes('(cm)'))) return;

            const match = name.match(/properties\[(.+?)\s+\(in\)\]|properties\[(.+?)\s+\(cm\)\]/);
            if (!match) return;

            const measName = match[1] || match[2];
            const measConfig = config.measurements[measName];
            const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[selectedCategory] : null;
            const isIncluded = categoryInfo && categoryInfo.included === true;
            const value = input.value && input.value.trim() !== '' ? input.value : '';

            if (!isIncluded || value === '') {
              input.removeAttribute('name');
              input.setAttribute('data-removed', 'true');
            }
          });
        }
      });
    }

    function delayedInitialize() {
      initialize();
      updateAddToCartButton();
      updateBannerVisibility();
    }

    window.addEventListener('pageshow', function () {
      initialize();
      updateAddToCartButton();
      updateBannerVisibility();
    });

    document.addEventListener('cart:updated', updateBannerVisibility);

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', delayedInitialize);
    } else {
      delayedInitialize();
    }
  })();

  function toggleCustomFields() {
    document.querySelectorAll('.custom-text').forEach((el) => {
      el.style.display = 'block';
    });
  }
</script>
