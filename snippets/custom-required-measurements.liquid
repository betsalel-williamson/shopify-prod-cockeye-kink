{% comment %}
  Custom Required Measurements Snippet
  Configuration: Edit the JSON below to customize measurements
  Structure: Categories define which measurements are included (true/false for each measurement)
  This inverted structure makes it easy to see all measurements for a category at once
{% endcomment %}

{%- comment -%} Measurement Configuration for JavaScript {%- endcomment -%}
{%- comment -%} Edit the JSON below to configure measurements and categories {%- endcomment -%}
<script type="application/json" id="measurement-config-raw">
  {
    "default_step_in": 0.5,
    "default_step_cm": 0.5,
    "measurements": {
      "Neck": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Chest": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Shoulders": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Torso": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Stomach": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Waist": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Butt": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Butt Rise": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Upper Thigh": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Lower Thigh": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Knee": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Calf": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Ankle": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Inseam": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Crotch": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Bicep": {
        "min_in": 0.5,
        "max_in": 300
      },
      "Hips": {
        "min_in": 0.5,
        "max_in": 300
      }
    },
    "categories": {
      "Deluxe Harness": {
        "Neck": true,
        "Chest": true,
        "Shoulders": true,
        "Torso": true,
        "Waist": true
      },
      "Standard Harness": {
        "Neck": true,
        "Chest": true,
        "Shoulders": true,
        "Torso": true,
        "Waist": true
      },
      "Suspender Harness": {
        "Neck": true,
        "Chest": true,
        "Shoulders": true,
        "Torso": true,
        "Waist": true
      },
      "Dogtag/Pigtag": {
        "Neck": false
      },
      "Chaps": {
        "Waist": true,
        "Upper Thigh": true,
        "Lower Thigh": true,
        "Knee": true,
        "Calf": true,
        "Ankle": true,
        "Hips": false
      },
      "Shirt": {
        "Chest": true,
        "Shoulders": true,
        "Torso": true,
        "Stomach": true,
        "Bicep": true
      },
      "Pants": {
        "Waist": true,
        "Butt": true,
        "Butt Rise": true,
        "Upper Thigh": true,
        "Lower Thigh": true,
        "Knee": true,
        "Calf": true,
        "Ankle": true,
        "Inseam": true,
        "Crotch": true,
        "Hips": false
      },
      "Suspenders": {
        "Chest": true,
        "Shoulders": true,
        "Waist": true
      },
      "Other": {
        "Neck": false,
        "Chest": false,
        "Shoulders": false,
        "Torso": false,
        "Stomach": false,
        "Waist": false,
        "Butt": false,
        "Butt Rise": false,
        "Upper Thigh": false,
        "Lower Thigh": false,
        "Knee": false,
        "Calf": false,
        "Ankle": false,
        "Inseam": false,
        "Crotch": false,
        "Bicep": false,
        "Hips": false
      }
    }
  }
</script>
<script type="application/json" id="measurement-config">
  {
    "harness_details": {{ harness_categories | json }},
    "notes_section": {{ notes_categories | json }}
  }
</script>

{%- liquid
  comment
    SINGLE SOURCE OF TRUTH - Categories list
    These category names are used as keys in the categories section of the JSON config
  endcomment
  assign categories_list = 'Deluxe Harness,Standard Harness,Suspender Harness,Dogtag/Pigtag,Chaps,Shirt,Pants,Suspenders,Other' | split: ','

  comment
    Measurement Configuration - JSON Dictionary Format (Inverted Structure)
    Structure: categories at top level, each category lists only included measurements
    - If measurement exists and value is true: included and required
    - If measurement exists and value is false: included but optional
    - If measurement doesn't exist: not shown for this category
    Measurement properties: min_in, max_in are required (in inches)
    - min_cm, max_cm can be specified to override auto-conversion (2.54x)
    - step_in, step_cm can be overridden per measurement, otherwise defaults are used
    Note: JSON is defined in script tag below for better formatting
  endcomment

  comment
    Measurement names list for Liquid iteration (for HTML generation)
    Must match the keys in measurements_json
  endcomment
  assign measurement_names = 'Neck,Chest,Shoulders,Torso,Stomach,Waist,Butt,Butt Rise,Upper Thigh,Lower Thigh,Knee,Calf,Ankle,Inseam,Crotch,Bicep,Hips' | split: ','

  assign harness_categories = 'Deluxe Harness,Standard Harness,Suspender Harness' | split: ','
  assign notes_categories = 'Dogtag/Pigtag,Chaps,Shirt,Pants,Suspenders,Other' | split: ','

  assign leather_colors = 'Black,White,Red,Blue,Green,Yellow,Orange,Purple' | split: ','
  assign left_front_plates = 'Bear Paw,Puppy Paw,Fist Image,Pig Image,Boot Image,Biohazard Symbol,Cigar Man' | split: ','
  assign right_front_plates = 'Bear Paw,Puppy Paw,Fist Image,Pig Image,Boot Image,Biohazard Symbol,Cigar Man' | split: ','
  assign back_plates = 'Bear Paw,Puppy Paw,Fist Image,Pig Image,Wesco Boot,Watersports,Happy Puppy' | split: ','
  assign long_sliders = 'None,Brass,Steel' | split: ','

  assign order_tag_name = '_custom'
  assign order_tag_value = 'custom'
  assign banner_text = 'Order has not been submitted yet'

  comment
    Show banner as long as order is in cart and not submitted:
    - On product page: always show (order hasn't been added yet)
    - On cart page: show if cart has items (order is in cart)
    - On checkout/thank you pages: hide (order has been submitted)
  endcomment
  assign banner_enabled = true
  if template.name == 'cart'
    if cart.item_count > 0
      assign banner_enabled = true
    else
      assign banner_enabled = false
    endif
  endif
  if template.name == 'checkout'
    assign banner_enabled = false
  endif
  if request.page_type == 'checkout'
    assign banner_enabled = false
  endif
-%}

<style>
  .order-status-banner {
    background-color: #fff3cd;
    border: 2px solid #ffc107;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 20px;
    font-weight: bold;
    color: #856404;
    text-align: center;
  }

  .unit-toggle-container {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    padding: 8px 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
  }

  .unit-toggle-label {
    font-weight: bold;
    margin-right: 8px;
  }

  .unit-toggle-buttons {
    display: flex;
    gap: 8px;
  }

  .unit-toggle-button {
    padding: 6px 16px;
    border: 2px solid #ccc;
    border-radius: 6px;
    background-color: white;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
  }

  .unit-toggle-button.active {
    background-color: #444;
    color: #fff;
    border-color: #444;
  }

  .measurement-select {
    font-weight: bold;
    color: black;
    width: 6em;
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
  }

  .measurements-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;
    margin-bottom: 16px;
  }

  .measurements-group label {
    display: block;
    margin-bottom: 4px;
    font-weight: bold;
  }

  .measurement-field {
    display: none;
  }

  .measurement-field.active {
    display: block;
  }

  .options-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 16px;
  }

  .option-button {
    background-color: #eee;
    border: 2px solid #ccc;
    border-radius: 8px;
    padding: 10px 18px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .option-button.selected {
    background-color: #444;
    color: #fff;
  }

  .conditional-section {
    display: none;
    margin-top: 16px;
    padding: 10px;
    background-color: #f9f9f9;
    border-radius: 8px;
  }

  .conditional-section.active {
    display: block;
  }

  .conditional-section label {
    display: block;
    margin-top: 12px;
    margin-bottom: 4px;
    font-weight: bold;
  }

  .conditional-section label:first-child {
    margin-top: 0;
  }

  .conditional-section select {
    display: block;
    width: 100%;
    margin-bottom: 8px;
  }

  .conditional-section .custom-text {
    display: block;
    width: 100%;
    margin-top: 8px;
    margin-bottom: 8px;
  }

  .custom-text {
    margin-top: 8px;
    display: none;
  }

  .custom-toggle-button {
    display: inline-block;
    margin-top: 12px;
    background-color: #ccc;
    padding: 8px 14px;
    font-weight: bold;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .custom-toggle-button:hover {
    background-color: #aaa;
  }
</style>

{%- comment -%} Order Status Banner - Displayed as long as order is in cart and not submitted {%- endcomment -%}
{%- if banner_enabled -%}
  <div class="order-status-banner" id="order-status-banner">
    {{ banner_text }}
  </div>
{%- endif -%}

{%- comment -%} Category Selection Buttons {%- endcomment -%}
<div class="options-group" id="optionButtons">
  {%- for category in categories_list -%}
    <button
      type="button"
      class="option-button"
      data-index="{{ forloop.index0 }}"
      data-label="{{ category }}"
    >
      {{ category }}
    </button>
  {%- endfor -%}
</div>

{%- comment -%} Unit of Measure - First property to indicate measurement unit used {%- endcomment -%}
<input
  type="hidden"
  id="unitOfMeasure"
  name="properties[Unit of Measure]"
  value="Measured in Inches"
  form="product-form-{{ section.id }}"
>

<input type="hidden" id="selectedOption" name="properties[Selected Option]" form="product-form-{{ section.id }}">

{%- comment -%} Custom Order Tagging {%- endcomment -%}
<input
  type="hidden"
  name="properties[{{ order_tag_name }}]"
  value="{{ order_tag_value }}"
  form="product-form-{{ section.id }}"
>

{%- comment -%} Unit Toggle {%- endcomment -%}
<div class="unit-toggle-container">
  <span class="unit-toggle-label">Unit:</span>
  <div class="unit-toggle-buttons">
    <button type="button" class="unit-toggle-button active" data-unit="in">Inches</button>
    <button type="button" class="unit-toggle-button" data-unit="cm">Centimeters</button>
  </div>
</div>

{%- comment -%} Measurement Fields {%- endcomment -%}
<div class="measurements-group" id="measurementsGroup">
  {%- for meas_name in measurement_names -%}
    {%- assign handle = meas_name | handleize -%}
    {%- comment -%} Default values - actual config comes from JSON in JavaScript {%- endcomment -%}
    {%- assign min_in = 0.5 -%}
    {%- assign max_in = 300.0 -%}
    {%- assign step_in = 0.5 -%}
    {%- assign step_cm = 0.5 -%}

    {%- comment -%} Calculate CM min/max from inches, rounded to nearest whole cm {%- endcomment -%}
    {%- assign min_cm_raw = min_in | times: 2.54 -%}
    {%- assign min_cm = min_cm_raw | floor -%}
    {%- assign max_cm_raw = max_in | times: 2.54 -%}
    {%- assign max_cm = max_cm_raw | floor -%}

    <div
      class="measurement-field"
      id="measurement-{{ handle }}"
      data-measurement="{{ meas_name }}"
      data-min-in="{{ min_in }}"
      data-max-in="{{ max_in }}"
      data-step-in="{{ step_in }}"
      data-step-cm="{{ step_cm }}"
      data-min-cm="{{ min_cm }}"
      data-max-cm="{{ max_cm }}"
    >
      <label for="{{ handle }}-in">{{ meas_name }}</label>
      <select
        id="{{ handle }}-in"
        name="properties[{{ meas_name }} (in)]"
        form="product-form-{{ section.id }}"
        class="measurement-select measurement-in"
        data-measurement="{{ meas_name }}"
      >
        <option value="" disabled selected>—</option>
        {%- assign steps = max_in | divided_by: step_in | floor -%}
        {%- for i in (0..steps) -%}
          {%- assign val = i | times: step_in | plus: min_in -%}
          {%- if val <= max_in -%}
            {%- if step_in == 0.5 -%}
              {%- assign display_val = val | round: 1 -%}
            {%- else -%}
              {%- assign display_val = val | round: 2 -%}
            {%- endif -%}
            <option value="{{ val }}">{{ display_val }}</option>
          {%- endif -%}
        {%- endfor -%}
      </select>
      <select
        id="{{ handle }}-cm"
        name="properties[{{ meas_name }} (cm)]"
        form="product-form-{{ section.id }}"
        class="measurement-select measurement-cm"
        data-measurement="{{ meas_name }}"
        style="display: none;"
      >
        <option value="" disabled selected>—</option>
        {%- assign steps_cm = max_cm | divided_by: step_cm | floor -%}
        {%- for i in (0..steps_cm) -%}
          {%- assign val_cm = i | times: step_cm | plus: min_cm -%}
          {%- if val_cm <= max_cm -%}
            {%- if step_cm == 0.5 -%}
              {%- assign display_val_cm = val_cm | round: 1 -%}
            {%- elsif step_cm >= 1 -%}
              {%- assign display_val_cm = val_cm | round: 0 -%}
            {%- else -%}
              {%- assign display_val_cm = val_cm | round: 2 -%}
            {%- endif -%}
            <option value="{{ val_cm }}">{{ display_val_cm }}</option>
          {%- endif -%}
        {%- endfor -%}
      </select>
    </div>
  {%- endfor -%}
</div>

{%- comment -%} Harness Details Section {%- endcomment -%}
<div class="conditional-section" id="harness-details">
  <label>Leather Color</label>
  <select name="properties[Leather Color]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for color in leather_colors -%}
      <option>{{ color }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Leather Color - Text]"
    class="custom-text"
    placeholder="Enter custom color"
    form="product-form-{{ section.id }}"
  >

  <label>Left Front Plate</label>
  <select name="properties[Left Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in left_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Left Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Right Front Plate</label>
  <select name="properties[Right Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in right_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Right Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Back Plate</label>
  <select name="properties[Back Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in back_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Back Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Long Sliders</label>
  <select name="properties[Long Sliders]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for slider in long_sliders -%}
      <option>{{ slider }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Long Sliders - Text]"
    class="custom-text"
    placeholder="Enter custom sliders"
    form="product-form-{{ section.id }}"
  >

  <div>
    <button type="button" class="custom-toggle-button" onclick="toggleCustomFields()">
      Don't see a color listed? Click here
    </button>
  </div>
</div>

{%- comment -%} Notes Section {%- endcomment -%}
<div class="conditional-section" id="notes-section">
  <label>Notes</label>
  <textarea
    name="properties[Notes]"
    placeholder="Enter your notes here"
    form="product-form-{{ section.id }}"
  ></textarea>
  <label>Event (Optional)</label>
  <textarea
    name="properties[Event (Optional)]"
    placeholder="Event name or details"
    form="product-form-{{ section.id }}"
  ></textarea>
</div>

<script>
  (function () {
    'use strict';

    // Load configuration from JSON script tags
    const configElement = document.getElementById('measurement-config');
    const configRaw = configElement ? JSON.parse(configElement.textContent) : {};

    const configDataElement = document.getElementById('measurement-config-raw');
    const configData = configDataElement ? JSON.parse(configDataElement.textContent) : {};

    // Convert inverted structure: categories -> measurements to measurements -> categories
    const measurements = {};
    const measurementsData = configData.measurements || {};
    const categoriesData = configData.categories || {};
    const defaultStepIn = configData.default_step_in || 0.5;
    const defaultStepCm = configData.default_step_cm || 0.5;

    // Build measurements with their category lists and required flags
    for (const [measName, measConfig] of Object.entries(measurementsData)) {
      const categoryInfo = {};
      // Find which categories include this measurement and if it's required
      for (const [categoryName, categoryMeasurements] of Object.entries(categoriesData)) {
        if (categoryMeasurements.hasOwnProperty(measName)) {
          // Measurement exists in category - value determines if required
          categoryInfo[categoryName] = {
            included: true,
            required: categoryMeasurements[measName] === true,
          };
        }
      }

      // Convert min/max from inches to cm if not explicitly provided
      const minIn = measConfig.min_in;
      const maxIn = measConfig.max_in;
      const minCm = measConfig.min_cm !== undefined ? measConfig.min_cm : Math.floor(minIn * 2.54);
      const maxCm = measConfig.max_cm !== undefined ? measConfig.max_cm : Math.floor(maxIn * 2.54);

      measurements[measName] = {
        min_in: minIn,
        max_in: maxIn,
        min_cm: minCm,
        max_cm: maxCm,
        step_in: measConfig.step_in !== undefined ? measConfig.step_in : defaultStepIn,
        step_cm: measConfig.step_cm !== undefined ? measConfig.step_cm : defaultStepCm,
        categories: categoryInfo,
      };
    }

    const config = {
      measurements: measurements,
      categories: {
        harness_details: configRaw.harness_details || [],
        notes_section: configRaw.notes_section || [],
      },
    };
    const INCH_TO_CM = 2.54;
    const CM_TO_INCH = 1 / 2.54;

    // State
    let currentUnit = 'in';
    let selectedCategory = null;
    const measurementValues = new Map();

    // DOM Elements
    const optionButtons = document.querySelectorAll('.option-button');
    const selectedInput = document.getElementById('selectedOption');
    const harnessSection = document.getElementById('harness-details');
    const notesSection = document.getElementById('notes-section');
    const measurementsGroup = document.getElementById('measurementsGroup');
    const unitToggleButtons = document.querySelectorAll('.unit-toggle-button');
    const productForm = document.querySelector('#product-form-{{ section.id }}');
    // Find the add to cart button by ID (matching buy-buttons.liquid pattern)
    const buttonId = 'ProductSubmitButton-{{ section.id }}';
    let addToCartButton = document.getElementById(buttonId);

    // Fallback: try finding by name attribute if ID doesn't work
    if (!addToCartButton && productForm) {
      addToCartButton = productForm.querySelector('button[name="add"]');
    }

    if (!addToCartButton) {
      console.warn('Could not find add to cart button with ID:', buttonId);
    }

    // Initialize - reset all fields
    function initialize() {
      // Reset unit of measure
      const unitOfMeasureInput = document.getElementById('unitOfMeasure');
      if (unitOfMeasureInput) {
        unitOfMeasureInput.value = 'Measured in Inches'; // Default to inches
      }

      // Reset category selection
      optionButtons.forEach((btn) => btn.classList.remove('selected'));
      if (selectedInput) selectedInput.value = '';
      selectedCategory = null;

      // Hide all sections
      if (harnessSection) harnessSection.classList.remove('active');
      if (notesSection) notesSection.classList.remove('active');

      // Hide all measurements
      document.querySelectorAll('.measurement-field').forEach((field) => {
        field.classList.remove('active');
        const inSelect = field.querySelector('.measurement-in');
        const cmSelect = field.querySelector('.measurement-cm');
        if (inSelect) {
          inSelect.value = '';
          inSelect.removeAttribute('required');
        }
        if (cmSelect) {
          cmSelect.value = '';
          cmSelect.removeAttribute('required');
        }
      });

      // Hide custom text fields
      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });

      // Reset unit toggle
      currentUnit = 'in';
      unitToggleButtons.forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.unit === 'in');
      });

      updateMeasurementVisibility();

      // Clear measurement values
      measurementValues.clear();

      // Auto-select first category
      if (optionButtons.length > 0) {
        const firstButton = optionButtons[0];
        firstButton.classList.add('selected');
        selectedCategory = firstButton.dataset.label;
        if (selectedInput) selectedInput.value = selectedCategory;

        // Show/hide sections based on first category
        if (harnessSection && config.categories && config.categories.harness_details) {
          harnessSection.classList.toggle('active', config.categories.harness_details.includes(selectedCategory));
        }
        if (notesSection && config.categories && config.categories.notes_section) {
          notesSection.classList.toggle(
            'active',
            config.categories.notes_section.includes(selectedCategory) || selectedCategory === 'Other'
          );
        }

        // Update measurements for first category
        updateMeasurementsForCategory(selectedCategory);
      }

      // Update add to cart button state - disable on load (following validated-text-input pattern)
      if (addToCartButton) {
        addToCartButton.disabled = true;
        addToCartButton.style.opacity = '0.5';
      }
      // Then run validation to set proper state
      updateAddToCartButton();
    }

    // Update measurement visibility based on unit
    function updateMeasurementVisibility() {
      document.querySelectorAll('.measurement-field').forEach((field) => {
        const inSelect = field.querySelector('.measurement-in');
        const cmSelect = field.querySelector('.measurement-cm');
        if (inSelect && cmSelect) {
          if (currentUnit === 'in') {
            inSelect.style.display = 'block';
            cmSelect.style.display = 'none';
          } else {
            inSelect.style.display = 'none';
            cmSelect.style.display = 'block';
          }
        }
      });
    }

    // Convert value between units
    function convertValue(value, fromUnit, toUnit) {
      if (fromUnit === toUnit) return value;
      if (fromUnit === 'in' && toUnit === 'cm') {
        return value * INCH_TO_CM;
      } else if (fromUnit === 'cm' && toUnit === 'in') {
        return value * CM_TO_INCH;
      }
      return value;
    }

    // Get closest step value
    function getClosestStepValue(value, step) {
      return Math.round(value / step) * step;
    }

    // Update measurement when unit changes
    function updateMeasurementOnUnitChange() {
      document.querySelectorAll('.measurement-field.active').forEach((field) => {
        const measName = field.dataset.measurement;
        const inSelect = field.querySelector('.measurement-in');
        const cmSelect = field.querySelector('.measurement-cm');
        const stepIn = parseFloat(field.dataset.stepIn);
        const stepCm = parseFloat(field.dataset.stepCm);
        const minCm = parseFloat(field.dataset.minCm);
        const maxCm = parseFloat(field.dataset.maxCm);

        if (currentUnit === 'in') {
          // Switching to inches - convert from CM if we have a value
          if (cmSelect && cmSelect.value && cmSelect.value !== '' && cmSelect.value !== '—') {
            const cmValue = parseFloat(cmSelect.value);
            const inValue = convertValue(cmValue, 'cm', 'in');
            const closestIn = getClosestStepValue(inValue, stepIn);

            // Find the closest matching option in the inches select
            if (inSelect) {
              const options = Array.from(inSelect.options);
              let bestMatch = null;
              let bestDiff = Infinity;

              options.forEach((opt) => {
                if (opt.value && opt.value !== '' && opt.value !== '—') {
                  const optValue = parseFloat(opt.value);
                  const diff = Math.abs(optValue - closestIn);
                  if (diff < bestDiff) {
                    bestDiff = diff;
                    bestMatch = opt;
                  }
                }
              });

              if (bestMatch && bestDiff < stepIn * 2) {
                inSelect.value = bestMatch.value;
              } else {
                inSelect.value = closestIn.toFixed(stepIn < 1 ? 2 : 0);
              }
              measurementValues.set(measName, { in: parseFloat(inSelect.value), cm: cmValue });
            }
          }
        } else {
          // Switching to CM - convert from inches if we have a value
          if (inSelect && inSelect.value && inSelect.value !== '' && inSelect.value !== '—') {
            const inValue = parseFloat(inSelect.value);
            const cmValue = convertValue(inValue, 'in', 'cm');
            const closestCm = getClosestStepValue(cmValue, stepCm);
            // Ensure value is within CM range
            const clampedCm = Math.max(minCm, Math.min(maxCm, closestCm));

            // Find the closest matching option in the cm select
            if (cmSelect) {
              const options = Array.from(cmSelect.options);
              let bestMatch = null;
              let bestDiff = Infinity;

              options.forEach((opt) => {
                if (opt.value && opt.value !== '' && opt.value !== '—') {
                  const optValue = parseFloat(opt.value);
                  const diff = Math.abs(optValue - clampedCm);
                  if (diff < bestDiff) {
                    bestDiff = diff;
                    bestMatch = opt;
                  }
                }
              });

              if (bestMatch && bestDiff < stepCm * 2) {
                cmSelect.value = bestMatch.value;
              } else {
                cmSelect.value = clampedCm.toFixed(stepCm < 1 ? 2 : 0);
              }
              measurementValues.set(measName, { in: inValue, cm: parseFloat(cmSelect.value) });
            }
          }
        }
      });
      updateMeasurementVisibility();
      updateAddToCartButton();
    }

    // Show/hide measurements based on category
    function updateMeasurementsForCategory(category) {
      if (!category || !config.measurements) return;

      document.querySelectorAll('.measurement-field').forEach((field) => {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];

        // Check if measurement is included in this category
        const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[category] : null;

        if (categoryInfo && categoryInfo.included) {
          field.classList.add('active');
          // Set required attribute based on category config
          const inSelect = field.querySelector('.measurement-in');
          const cmSelect = field.querySelector('.measurement-cm');
          if (categoryInfo.required) {
            if (inSelect) inSelect.setAttribute('required', 'required');
            if (cmSelect) cmSelect.setAttribute('required', 'required');
          } else {
            if (inSelect) inSelect.removeAttribute('required');
            if (cmSelect) cmSelect.removeAttribute('required');
          }
        } else {
          field.classList.remove('active');
          // Clear values when hiding
          const inSelect = field.querySelector('.measurement-in');
          const cmSelect = field.querySelector('.measurement-cm');
          if (inSelect) {
            inSelect.value = '';
            inSelect.removeAttribute('required');
          }
          if (cmSelect) {
            cmSelect.value = '';
            cmSelect.removeAttribute('required');
          }
          measurementValues.delete(measName);
        }
      });
    }

    // Validate required fields
    function validateRequiredFields() {
      // Must have a category selected
      if (!selectedCategory || !config.measurements) {
        return false;
      }

      const requiredMeasurements = [];
      const activeFields = document.querySelectorAll('.measurement-field.active');

      activeFields.forEach((field) => {
        const measName = field.dataset.measurement;
        if (!measName) return;

        const measConfig = config.measurements[measName];
        if (!measConfig) return;

        // Check if this measurement is required for the selected category
        const categoryInfo = measConfig.categories ? measConfig.categories[selectedCategory] : null;
        if (!categoryInfo) return;

        const isRequired = categoryInfo.included === true && categoryInfo.required === true;
        if (!isRequired) return;

        // This measurement is required - check if it has a value
        const inSelect = field.querySelector('.measurement-in');
        const cmSelect = field.querySelector('.measurement-cm');

        // Check if either select has a valid value (not placeholder)
        // The placeholder option has value="" and is disabled, so we check for non-empty value
        let inHasValue = false;
        let cmHasValue = false;

        if (inSelect) {
          // Check if selected option is not the placeholder (first option with empty value)
          const selectedOption = inSelect.options[inSelect.selectedIndex];
          inHasValue =
            selectedOption && selectedOption.value !== '' && selectedOption.value !== null && !selectedOption.disabled;
        }

        if (cmSelect) {
          // Check if selected option is not the placeholder (first option with empty value)
          const selectedOption = cmSelect.options[cmSelect.selectedIndex];
          cmHasValue =
            selectedOption && selectedOption.value !== '' && selectedOption.value !== null && !selectedOption.disabled;
        }

        // If neither has a value, it's missing
        if (!inHasValue && !cmHasValue) {
          requiredMeasurements.push(measName);
        }
      });

      // Also validate harness customization fields if harness section is visible
      if (harnessSection && harnessSection.classList.contains('active')) {
        const harnessFields = [
          'properties[Leather Color]',
          'properties[Left Front Plate]',
          'properties[Right Front Plate]',
          'properties[Back Plate]',
          'properties[Long Sliders]',
        ];

        harnessFields.forEach((fieldName) => {
          const select = document.querySelector(`select[name="${fieldName}"]`);
          if (!select) return;

          // Check if selected option is not the placeholder
          const selectedOption = select.options[select.selectedIndex];
          const hasValue =
            selectedOption &&
            selectedOption.value !== '' &&
            selectedOption.value !== null &&
            selectedOption.value !== 'Select one';

          // Check if custom text field is filled as alternative
          const customTextName = fieldName.replace(']', ' - Text]');
          const customText = document.querySelector(`input[name="${customTextName}"]`);
          let hasCustomText = false;

          if (customText) {
            const customVal = customText.value;
            hasCustomText = customVal !== null && customVal !== undefined && String(customVal).trim() !== '';
          }

          if (!hasValue && !hasCustomText) {
            // Extract field name for display
            const fieldDisplayName = fieldName.replace('properties[', '').replace(']', '');
            requiredMeasurements.push(fieldDisplayName);
          }
        });
      }

      return requiredMeasurements.length === 0;
    }

    // Update add to cart button state (following validated-text-input.liquid pattern)
    function updateAddToCartButton() {
      // Re-find button in case DOM changed
      if (!addToCartButton) {
        addToCartButton = document.getElementById(buttonId);
      }
      if (!addToCartButton && productForm) {
        addToCartButton = productForm.querySelector('button[name="add"]');
      }

      if (!addToCartButton) {
        return;
      }

      const isValid = validateRequiredFields();

      // Follow validated-text-input pattern: set disabled and opacity
      if (!isValid) {
        addToCartButton.disabled = true;
        addToCartButton.style.opacity = '0.5';
        addToCartButton.setAttribute('disabled', 'disabled');
        addToCartButton.setAttribute('aria-disabled', 'true');
        addToCartButton.title = 'Please select a category and fill all required measurements';
      } else {
        addToCartButton.disabled = false;
        addToCartButton.style.opacity = '1';
        addToCartButton.removeAttribute('disabled');
        addToCartButton.removeAttribute('aria-disabled');
        addToCartButton.removeAttribute('title');
      }
    }

    // Sync measurement values between units
    function syncMeasurementValues(measName, value, sourceUnit) {
      const targetUnit = sourceUnit === 'in' ? 'cm' : 'in';
      const convertedValue = convertValue(parseFloat(value), sourceUnit, targetUnit);

      document.querySelectorAll('.measurement-field').forEach((field) => {
        if (field.dataset.measurement === measName) {
          const step = sourceUnit === 'in' ? parseFloat(field.dataset.stepCm) : parseFloat(field.dataset.stepIn);
          const minCm = parseFloat(field.dataset.minCm);
          const maxCm = parseFloat(field.dataset.maxCm);
          const closestValue = getClosestStepValue(convertedValue, step);
          const targetSelect = field.querySelector(`.measurement-${targetUnit}`);

          if (targetSelect) {
            // Clamp value to valid range for CM
            let finalValue = closestValue;
            if (targetUnit === 'cm') {
              finalValue = Math.max(minCm, Math.min(maxCm, closestValue));
            }

            // Find the closest matching option
            const options = Array.from(targetSelect.options);
            let bestMatch = null;
            let bestDiff = Infinity;

            options.forEach((opt) => {
              if (opt.value && opt.value !== '') {
                const optValue = parseFloat(opt.value);
                const diff = Math.abs(optValue - finalValue);
                if (diff < bestDiff) {
                  bestDiff = diff;
                  bestMatch = opt;
                }
              }
            });

            // Set the value to the best matching option
            if (bestMatch && bestDiff < step * 2) {
              targetSelect.value = bestMatch.value;
            } else {
              // Fallback: set to closest value if no good match found
              targetSelect.value = finalValue.toFixed(step < 1 ? 2 : 0);
            }

            measurementValues.set(measName, {
              in: sourceUnit === 'in' ? parseFloat(value) : parseFloat(targetSelect.value) / INCH_TO_CM,
              cm: sourceUnit === 'cm' ? parseFloat(value) : parseFloat(targetSelect.value),
            });
          }
        }
      });
    }

    // Category selection handlers
    optionButtons.forEach((button) => {
      button.addEventListener('click', function () {
        optionButtons.forEach((btn) => btn.classList.remove('selected'));
        this.classList.add('selected');
        selectedCategory = this.dataset.label;
        if (selectedInput) selectedInput.value = selectedCategory;

        // Show/hide sections
        if (harnessSection && config.categories && config.categories.harness_details) {
          harnessSection.classList.toggle('active', config.categories.harness_details.includes(selectedCategory));
        }
        if (notesSection && config.categories && config.categories.notes_section) {
          notesSection.classList.toggle(
            'active',
            config.categories.notes_section.includes(selectedCategory) || selectedCategory === 'Other'
          );
        }

        // Hide custom fields when switching
        document.querySelectorAll('.custom-text').forEach((el) => {
          el.style.display = 'none';
        });

        // Update measurements
        updateMeasurementsForCategory(selectedCategory);
        updateAddToCartButton();
      });
    });

    // Unit toggle handlers
    unitToggleButtons.forEach((button) => {
      button.addEventListener('click', function () {
        currentUnit = this.dataset.unit;
        unitToggleButtons.forEach((btn) => {
          btn.classList.toggle('active', btn.dataset.unit === currentUnit);
        });

        // Update unit of measure property when unit changes
        const unitOfMeasureInput = document.getElementById('unitOfMeasure');
        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        updateMeasurementOnUnitChange();
        updateAddToCartButton();
      });
    });

    // Measurement change handlers
    document.querySelectorAll('.measurement-select').forEach((select) => {
      select.addEventListener('change', function () {
        const field = this.closest('.measurement-field');
        if (!field) return;

        const measName = field.dataset.measurement;
        const unit = this.classList.contains('measurement-in') ? 'in' : 'cm';

        if (this.value && this.value !== '') {
          syncMeasurementValues(measName, this.value, unit);
        }

        updateAddToCartButton();
      });
    });

    // Harness customization field change handlers
    const harnessSelects = document.querySelectorAll('#harness-details select');
    harnessSelects.forEach((select) => {
      select.addEventListener('change', function () {
        updateAddToCartButton();
      });
    });

    // Harness customization custom text field change handlers
    const harnessCustomTexts = document.querySelectorAll('#harness-details .custom-text');
    harnessCustomTexts.forEach((input) => {
      input.addEventListener('input', function () {
        updateAddToCartButton();
      });
    });

    // Form submission handler - filter properties
    if (productForm) {
      productForm.addEventListener('submit', function (event) {
        if (!validateRequiredFields()) {
          event.preventDefault();
          alert('Please select a category and fill all required measurements.');
          return false;
        }

        // Ensure unit of measure property is set (first property in order)
        // This should already be set when unit changes, but ensure it's set here too
        const unitOfMeasureInput = document.getElementById('unitOfMeasure');
        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          // Also ensure it's in the form by setting the attribute
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        // Ensure both (in) and (cm) values are set for all active measurements
        document.querySelectorAll('.measurement-field.active').forEach((field) => {
          const measName = field.dataset.measurement;
          const inSelect = field.querySelector('.measurement-in');
          const cmSelect = field.querySelector('.measurement-cm');

          // If one has a value but the other doesn't, sync them
          if (inSelect && inSelect.value && (!cmSelect || !cmSelect.value)) {
            syncMeasurementValues(measName, inSelect.value, 'in');
          } else if (cmSelect && cmSelect.value && (!inSelect || !inSelect.value)) {
            syncMeasurementValues(measName, cmSelect.value, 'cm');
          }
        });

        // Remove measurement properties that don't belong to selected category or are empty
        if (selectedCategory && config.measurements) {
          const measurementInputs = this.querySelectorAll('select[name^="properties["]');

          measurementInputs.forEach((input) => {
            const name = input.getAttribute('name');
            if (name && (name.includes('(in)') || name.includes('(cm)'))) {
              // Extract measurement name
              const match = name.match(/properties\[(.+?)\s+\(in\)\]|properties\[(.+?)\s+\(cm\)\]/);
              if (match) {
                const measName = match[1] || match[2];
                const measConfig = config.measurements[measName];

                // Check if measurement is included in the selected category
                const categoryInfo =
                  measConfig && measConfig.categories ? measConfig.categories[selectedCategory] : null;
                const isIncluded = categoryInfo && categoryInfo.included === true;

                // Remove if not in category or empty
                const shouldRemove = !measConfig || !isIncluded || !input.value || input.value === '';

                if (shouldRemove) {
                  // Remove this input from form
                  input.removeAttribute('name');
                  input.setAttribute('data-removed', 'true');
                }
              }
            }
          });
        }
      });
    }

    // Update banner visibility based on page/cart state
    function updateBannerVisibility() {
      const banner = document.getElementById('order-status-banner');
      if (!banner) return;

      // Hide banner on checkout/thank you pages
      if (
        window.location.pathname.includes('/checkouts/') ||
        window.location.pathname.includes('/thank-you') ||
        window.location.pathname.includes('/checkout')
      ) {
        banner.style.display = 'none';
        return;
      }

      // Show banner on product page (default)
      if (window.location.pathname.includes('/products/')) {
        banner.style.display = 'block';
        return;
      }

      // On cart page, check if cart has items
      if (window.location.pathname.includes('/cart')) {
        // Check cart state via cart drawer or cart API
        fetch('/cart.js')
          .then((response) => response.json())
          .then((cart) => {
            if (cart.item_count > 0) {
              banner.style.display = 'block';
            } else {
              banner.style.display = 'none';
            }
          })
          .catch(() => {
            // If fetch fails, show banner by default
            banner.style.display = 'block';
          });
      }
    }

    // Initialize on load (following validated-text-input.liquid pattern)
    function delayedInitialize() {
      initialize();
      // Run validation immediately on load (like validated-text-input does)
      updateAddToCartButton();
      // Update banner visibility
      updateBannerVisibility();
    }

    // Handle pageshow event for back/forward cache - clear all values
    window.addEventListener('pageshow', function () {
      // Clear all values when navigating back/forward
      initialize();
      updateAddToCartButton();
      // Update banner visibility
      updateBannerVisibility();
    });

    // Listen for cart updates to show/hide banner
    document.addEventListener('cart:updated', function () {
      updateBannerVisibility();
    });

    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', delayedInitialize);
    } else {
      delayedInitialize();
    }
  })();

  // Toggle custom fields function (for harness details)
  function toggleCustomFields() {
    document.querySelectorAll('.custom-text').forEach((el) => {
      el.style.display = 'block';
    });
  }
</script>
