{% comment %}
  Custom Required Measurements Snippet
  Configuration: Edit the values inside the JSON config block below
  Structure: Categories define which measurements are required or optional
  This inverted structure makes it easy to see all measurements for a category at once
{% endcomment %}

{%- capture measurement_config_json -%}
{
  "measurements": [
    "Neck",
    "Chest",
    "Shoulders",
    "Torso",
    "Stomach",
    "Waist",
    "Butt",
    "Butt Rise",
    "Upper Thigh",
    "Lower Thigh",
    "Knee",
    "Calf",
    "Ankle",
    "Inseam",
    "Crotch",
    "Bicep",
    "Hips"
  ],
  "categories": {
    "Deluxe Harness": {
      "required": ["Neck", "Chest", "Shoulders", "Torso", "Waist"],
      "optional": []
    },
    "Standard Harness": {
      "required": ["Neck", "Chest", "Shoulders", "Torso", "Waist"],
      "optional": []
    },
    "Suspender Harness": {
      "required": ["Neck", "Chest", "Shoulders", "Torso", "Waist"],
      "optional": []
    },
    "Dogtag/Pigtag": {
      "required": [],
      "optional": ["Neck"]
    },
    "Chaps": {
      "required": ["Waist", "Upper Thigh", "Lower Thigh", "Knee", "Calf", "Ankle"],
      "optional": ["Hips"]
    },
    "Shirt": {
      "required": ["Chest", "Shoulders", "Torso", "Stomach", "Bicep"],
      "optional": []
    },
    "Pants": {
      "required": [
        "Waist",
        "Butt",
        "Butt Rise",
        "Upper Thigh",
        "Lower Thigh",
        "Knee",
        "Calf",
        "Ankle",
        "Inseam",
        "Crotch"
      ],
      "optional": ["Hips"]
    },
    "Suspenders": {
      "required": ["Chest", "Shoulders", "Waist"],
      "optional": []
    },
    "Other": {
      "required": [],
      "optional": [
        "Neck",
        "Chest",
        "Shoulders",
        "Torso",
        "Stomach",
        "Waist",
        "Butt",
        "Butt Rise",
        "Upper Thigh",
        "Lower Thigh",
        "Knee",
        "Calf",
        "Ankle",
        "Inseam",
        "Crotch",
        "Bicep",
        "Hips"
      ]
    }
  },
  "category_order": [
    "Deluxe Harness",
    "Standard Harness",
    "Suspender Harness",
    "Dogtag/Pigtag",
    "Chaps",
    "Shirt",
    "Pants",
    "Suspenders",
    "Other"
  ],
  "harness_details": ["Deluxe Harness", "Standard Harness", "Suspender Harness"],
  "notes_section": ["Dogtag/Pigtag", "Chaps", "Shirt", "Pants", "Suspenders", "Other"],
  "harness_options": {
    "leather_colors": ["Black", "White", "Red", "Blue", "Green", "Yellow", "Orange", "Purple"],
    "plates": {
      "left_front": [
        "Bear Paw",
        "Puppy Paw",
        "Fist Image",
        "Pig Image",
        "Boot Image",
        "Biohazard Symbol",
        "Cigar Man"
      ],
      "right_front": [
        "Bear Paw",
        "Puppy Paw",
        "Fist Image",
        "Pig Image",
        "Boot Image",
        "Biohazard Symbol",
        "Cigar Man"
      ],
      "back": ["Bear Paw", "Puppy Paw", "Fist Image", "Pig Image", "Wesco Boot", "Watersports", "Happy Puppy"]
    },
    "long_sliders": ["None", "Brass", "Steel"]
  }
}
{%- endcapture -%}

<script type="application/json" id="measurement-config-raw">
  {{ measurement_config_json | strip }}
</script>

{%- assign measurement_config = measurement_config_json | strip | parse_json -%}
{%- assign measurement_names = measurement_config.measurements -%}
{%- assign categories_order = measurement_config.category_order -%}
{%- assign leather_colors = measurement_config.harness_options.leather_colors -%}
{%- assign left_front_plates = measurement_config.harness_options.plates.left_front -%}
{%- assign right_front_plates = measurement_config.harness_options.plates.right_front -%}
{%- assign back_plates = measurement_config.harness_options.plates.back -%}
{%- assign long_sliders = measurement_config.harness_options.long_sliders -%}

{%- liquid
  comment
    Configuration source of truth lives in the JSON block above.
    Liquid assigns only order metadata and banner defaults here.
  endcomment

  assign order_tag_name = '_custom'
  assign order_tag_value = 'custom'
  assign banner_text = 'Order has not been submitted yet'

  comment
    Show banner as long as order is in cart and not submitted:
    - On product page: always show (order hasn't been added yet)
    - On cart page: show if cart has items (order is in cart)
    - On checkout/thank you pages: hide (order has been submitted)
  endcomment
  assign banner_enabled = true
  if template.name == 'cart'
    if cart.item_count > 0
      assign banner_enabled = true
    else
      assign banner_enabled = false
    endif
  endif
  if template.name == 'checkout'
    assign banner_enabled = false
  endif
  if request.page_type == 'checkout'
    assign banner_enabled = false
  endif
-%}

<style>
  .order-status-banner {
    background-color: #fff3cd;
    border: 2px solid #ffc107;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 20px;
    font-weight: bold;
    color: #856404;
    text-align: center;
  }

  .unit-toggle-container {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    padding: 8px 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
  }

  .unit-toggle-label {
    font-weight: bold;
    margin-right: 8px;
  }

  .unit-toggle-buttons {
    display: flex;
    gap: 8px;
  }

  .unit-toggle-button {
    padding: 6px 16px;
    border: 2px solid #ccc;
    border-radius: 6px;
    background-color: white;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
  }

  .unit-toggle-button.active {
    background-color: #444;
    color: #fff;
    border-color: #444;
  }

  .measurement-input {
    font-weight: bold;
    color: black;
    width: 6em;
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
  }

  .measurements-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;
    margin-bottom: 16px;
  }

  .measurements-group label {
    display: block;
    margin-bottom: 4px;
    font-weight: bold;
  }

  .measurement-field {
    display: none;
  }

  .measurement-field.active {
    display: block;
  }

  .options-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 16px;
  }

  .option-button {
    background-color: #eee;
    border: 2px solid #ccc;
    border-radius: 8px;
    padding: 10px 18px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .option-button.selected {
    background-color: #444;
    color: #fff;
  }

  .conditional-section {
    display: none;
    margin-top: 16px;
    padding: 10px;
    background-color: #f9f9f9;
    border-radius: 8px;
  }

  .conditional-section.active {
    display: block;
  }

  .conditional-section label {
    display: block;
    margin-top: 12px;
    margin-bottom: 4px;
    font-weight: bold;
  }

  .conditional-section label:first-child {
    margin-top: 0;
  }

  .conditional-section select {
    display: block;
    width: 100%;
    margin-bottom: 8px;
  }

  .conditional-section .custom-text {
    display: block;
    width: 100%;
    margin-top: 8px;
    margin-bottom: 8px;
  }

  .custom-text {
    margin-top: 8px;
    display: none;
  }

  .custom-toggle-button {
    display: inline-block;
    margin-top: 12px;
    background-color: #ccc;
    padding: 8px 14px;
    font-weight: bold;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .custom-toggle-button:hover {
    background-color: #aaa;
  }
</style>

{%- comment -%} Order Status Banner - Displayed as long as order is in cart and not submitted {%- endcomment -%}
{%- if banner_enabled -%}
  <div class="order-status-banner" id="order-status-banner">
    {{ banner_text }}
  </div>
{%- endif -%}

{%- comment -%} Category Selection Buttons {%- endcomment -%}
<div class="options-group" id="optionButtons">
  {%- for category in categories_order -%}
    <button
      type="button"
      class="option-button"
      data-index="{{ forloop.index0 }}"
      data-label="{{ category }}"
    >
      {{ category }}
    </button>
  {%- endfor -%}
</div>

{%- comment -%} Unit of Measure - First property to indicate measurement unit used {%- endcomment -%}
<input
  type="hidden"
  id="unitOfMeasure"
  name="properties[Unit of Measure]"
  value="Measured in Inches"
  form="product-form-{{ section.id }}"
>

<input type="hidden" id="selectedOption" name="properties[Selected Option]" form="product-form-{{ section.id }}">

{%- comment -%} Custom Order Tagging {%- endcomment -%}
<input
  type="hidden"
  name="properties[{{ order_tag_name }}]"
  value="{{ order_tag_value }}"
  form="product-form-{{ section.id }}"
>

{%- comment -%} Unit Toggle {%- endcomment -%}
<div class="unit-toggle-container">
  <span class="unit-toggle-label">Unit:</span>
  <div class="unit-toggle-buttons">
    <button type="button" class="unit-toggle-button active" data-unit="in">Inches</button>
    <button type="button" class="unit-toggle-button" data-unit="cm">Centimeters</button>
  </div>
</div>

{%- comment -%} Measurement Fields {%- endcomment -%}
<div class="measurements-group" id="measurementsGroup">
  {%- for meas_name in measurement_names -%}
    {%- assign handle = meas_name | handleize -%}
    <div
      class="measurement-field"
      id="measurement-{{ handle }}"
      data-measurement="{{ meas_name }}"
    >
      <label for="{{ handle }}-in">{{ meas_name }}</label>
      <input
        type="text"
        inputmode="decimal"
        autocomplete="off"
        id="{{ handle }}-in"
        name="properties[{{ meas_name }} (in)]"
        form="product-form-{{ section.id }}"
        class="measurement-input measurement-in"
        data-measurement="{{ meas_name }}"
        placeholder="0.000"
      >
      <input
        type="text"
        inputmode="decimal"
        autocomplete="off"
        id="{{ handle }}-cm"
        name="properties[{{ meas_name }} (cm)]"
        form="product-form-{{ section.id }}"
        class="measurement-input measurement-cm"
        data-measurement="{{ meas_name }}"
        placeholder="0.000"
        style="display: none;"
      >
    </div>
  {%- endfor -%}
</div>

{%- comment -%} Harness Details Section {%- endcomment -%}
<div class="conditional-section" id="harness-details">
  <label>Leather Color</label>
  <select name="properties[Leather Color]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for color in leather_colors -%}
      <option>{{ color }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Leather Color - Text]"
    class="custom-text"
    placeholder="Enter custom color"
    form="product-form-{{ section.id }}"
  >

  <label>Left Front Plate</label>
  <select name="properties[Left Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in left_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Left Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Right Front Plate</label>
  <select name="properties[Right Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in right_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Right Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Back Plate</label>
  <select name="properties[Back Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in back_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Back Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Long Sliders</label>
  <select name="properties[Long Sliders]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for slider in long_sliders -%}
      <option>{{ slider }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Long Sliders - Text]"
    class="custom-text"
    placeholder="Enter custom sliders"
    form="product-form-{{ section.id }}"
  >

  <div>
    <button type="button" class="custom-toggle-button" onclick="toggleCustomFields()">
      Don't see a color listed? Click here
    </button>
  </div>
</div>

{%- comment -%} Notes Section {%- endcomment -%}
<div class="conditional-section" id="notes-section">
  <label>Notes</label>
  <textarea
    name="properties[Notes]"
    placeholder="Enter your notes here"
    form="product-form-{{ section.id }}"
  ></textarea>
  <label>Event (Optional)</label>
  <textarea
    name="properties[Event (Optional)]"
    placeholder="Event name or details"
    form="product-form-{{ section.id }}"
  ></textarea>
</div>

<script>
  (function () {
    'use strict';

    const configElement = document.getElementById('measurement-config-raw');
    const configData = configElement ? JSON.parse(configElement.textContent) : {};
    const categoriesData = configData.categories || {};
    const harnessDetailCategories = configData.harness_details || [];
    const notesSectionCategories = configData.notes_section || [];
    const measurementNames = configData.measurements || [];

    const measurements = {};
    measurementNames.forEach((measName) => {
      const categoryInfo = {};
      Object.entries(categoriesData).forEach(([categoryName, categoryConfig]) => {
        const requiredList = Array.isArray(categoryConfig.required) ? categoryConfig.required : [];
        const optionalList = Array.isArray(categoryConfig.optional) ? categoryConfig.optional : [];
        if (requiredList.includes(measName)) {
          categoryInfo[categoryName] = { included: true, required: true };
        } else if (optionalList.includes(measName)) {
          categoryInfo[categoryName] = { included: true, required: false };
        }
      });
      measurements[measName] = { categories: categoryInfo };
    });

    const config = {
      measurements,
      categories: {
        harness_details: harnessDetailCategories,
        notes_section: notesSectionCategories,
      },
    };

    const INCH_TO_CM = 2.54;
    const CM_TO_INCH = 1 / 2.54;
    const PRECISION = 3;

    let currentUnit = 'in';
    let selectedCategory = null;
    const measurementValues = new Map();
    let isSyncingValues = false;

    const optionButtons = document.querySelectorAll('.option-button');
    const measurementFields = Array.from(document.querySelectorAll('.measurement-field'));
    const measurementInputs = document.querySelectorAll('.measurement-input');
    const selectedInput = document.getElementById('selectedOption');
    const harnessSection = document.getElementById('harness-details');
    const notesSection = document.getElementById('notes-section');
    const unitToggleButtons = document.querySelectorAll('.unit-toggle-button');
    const productForm = document.querySelector('#product-form-{{ section.id }}');
    const unitOfMeasureInput = document.getElementById('unitOfMeasure');
    const harnessSelects = document.querySelectorAll('#harness-details select');
    const harnessCustomTexts = document.querySelectorAll('#harness-details .custom-text');

    const buttonId = 'ProductSubmitButton-{{ section.id }}';
    let addToCartButton = document.getElementById(buttonId);
    if (!addToCartButton && productForm) {
      addToCartButton = productForm.querySelector('button[name="add"]');
    }
    if (!addToCartButton) {
      console.warn('Could not find add to cart button with ID:', buttonId);
    }

    function formatValue(value) {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return '';
      }
      return Number(value).toFixed(PRECISION);
    }

    function parseValue(raw) {
      if (typeof raw !== 'string') return NaN;
      const trimmed = raw.trim();
      if (trimmed === '') return NaN;
      const parsed = Number(trimmed);
      return Number.isFinite(parsed) ? parsed : NaN;
    }

    function hasValidNumber(input) {
      if (!input) return false;
      return Number.isFinite(parseValue(input.value));
    }

    function clearMeasurementField(field) {
      const inInput = field.querySelector('.measurement-in');
      const cmInput = field.querySelector('.measurement-cm');
      if (inInput) inInput.value = '';
      if (cmInput) cmInput.value = '';
      measurementValues.delete(field.dataset.measurement);
    }

    function updateMeasurementVisibility() {
      measurementFields.forEach((field) => {
        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');
        if (!inInput || !cmInput) return;
        if (currentUnit === 'in') {
          inInput.style.display = 'block';
          cmInput.style.display = 'none';
        } else {
          inInput.style.display = 'none';
          cmInput.style.display = 'block';
        }
      });
    }

    function syncMeasurementValues(measName, sourceUnit, numericValue) {
      const field = document.querySelector(`.measurement-field[data-measurement="${measName}"]`);
      if (!field) return;
      const inInput = field.querySelector('.measurement-in');
      const cmInput = field.querySelector('.measurement-cm');
      if (!inInput || !cmInput) return;

      if (isSyncingValues) return;
      isSyncingValues = true;

      if (sourceUnit === 'in') {
        if (inInput.value !== formatValue(numericValue)) {
          inInput.value = formatValue(numericValue);
        }
        const converted = numericValue * INCH_TO_CM;
        cmInput.value = formatValue(converted);
        measurementValues.set(measName, { in: numericValue, cm: converted });
      } else {
        if (cmInput.value !== formatValue(numericValue)) {
          cmInput.value = formatValue(numericValue);
        }
        const converted = numericValue * CM_TO_INCH;
        inInput.value = formatValue(converted);
        measurementValues.set(measName, { in: converted, cm: numericValue });
      }

      isSyncingValues = false;
    }

    function updateMeasurementsForCategory(category) {
      measurementFields.forEach((field) => {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];
        const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[category] : null;

        if (categoryInfo && categoryInfo.included) {
          field.classList.add('active');
        } else {
          field.classList.remove('active');
          clearMeasurementField(field);
        }
      });
    }

    function validateRequiredFields() {
      if (!selectedCategory || !config.measurements) return false;

      const activeFields = document.querySelectorAll('.measurement-field.active');
      for (const field of activeFields) {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];
        if (!measConfig) continue;

        const categoryInfo = measConfig.categories ? measConfig.categories[selectedCategory] : null;
        if (!categoryInfo || !categoryInfo.required) continue;

        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');
        const hasValue = hasValidNumber(inInput) || hasValidNumber(cmInput);
        if (!hasValue) {
          return false;
        }
      }

      if (harnessSection && harnessSection.classList.contains('active')) {
        const harnessFields = [
          'properties[Leather Color]',
          'properties[Left Front Plate]',
          'properties[Right Front Plate]',
          'properties[Back Plate]',
          'properties[Long Sliders]',
        ];

        for (const fieldName of harnessFields) {
          const select = document.querySelector(`select[name="${fieldName}"]`);
          if (!select) continue;
          const selectedOption = select.options[select.selectedIndex];
          const hasSelectValue =
            selectedOption &&
            selectedOption.value !== '' &&
            selectedOption.value !== null &&
            selectedOption.value !== 'Select one';

          const customTextName = fieldName.replace(']', ' - Text]');
          const customText = document.querySelector(`input[name="${customTextName}"]`);
          const hasCustomText = customText && customText.value && customText.value.trim() !== '';

          if (!hasSelectValue && !hasCustomText) {
            return false;
          }
        }
      }

      return true;
    }

    function updateAddToCartButton() {
      if (!addToCartButton) {
        addToCartButton =
          document.getElementById(buttonId) || (productForm && productForm.querySelector('button[name="add"]'));
        if (!addToCartButton) {
          return;
        }
      }

      const isValid = validateRequiredFields();
      if (!isValid) {
        addToCartButton.disabled = true;
        addToCartButton.style.opacity = '0.5';
        addToCartButton.setAttribute('disabled', 'disabled');
        addToCartButton.setAttribute('aria-disabled', 'true');
        addToCartButton.title = 'Please select a category and fill all required measurements';
      } else {
        addToCartButton.disabled = false;
        addToCartButton.style.opacity = '1';
        addToCartButton.removeAttribute('disabled');
        addToCartButton.removeAttribute('aria-disabled');
        addToCartButton.removeAttribute('title');
      }
    }

    function updateSectionVisibility(category) {
      if (harnessSection) {
        const showHarness =
          config.categories && config.categories.harness_details
            ? config.categories.harness_details.includes(category)
            : false;
        harnessSection.classList.toggle('active', showHarness);
      }
      if (notesSection) {
        const showNotes =
          config.categories && config.categories.notes_section
            ? config.categories.notes_section.includes(category) || category === 'Other'
            : category === 'Other';
        notesSection.classList.toggle('active', showNotes);
      }

      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });
    }

    function updateMeasurementOnUnitChange() {
      const activeFields = document.querySelectorAll('.measurement-field.active');
      activeFields.forEach((field) => {
        const measName = field.dataset.measurement;
        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');

        if (!inInput || !cmInput) return;

        if (currentUnit === 'in') {
          const cmValue = parseValue(cmInput.value);
          if (Number.isFinite(cmValue)) {
            syncMeasurementValues(measName, 'cm', cmValue);
          }
        } else {
          const inValue = parseValue(inInput.value);
          if (Number.isFinite(inValue)) {
            syncMeasurementValues(measName, 'in', inValue);
          }
        }
      });

      updateMeasurementVisibility();
      updateAddToCartButton();
    }

    function initialize() {
      if (unitOfMeasureInput) {
        unitOfMeasureInput.value = 'Measured in Inches';
      }

      optionButtons.forEach((btn) => btn.classList.remove('selected'));
      if (selectedInput) selectedInput.value = '';
      selectedCategory = null;

      if (harnessSection) harnessSection.classList.remove('active');
      if (notesSection) notesSection.classList.remove('active');

      measurementFields.forEach((field) => {
        clearMeasurementField(field);
        field.classList.remove('active');
      });

      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });

      currentUnit = 'in';
      unitToggleButtons.forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.unit === 'in');
      });
      updateMeasurementVisibility();

      measurementValues.clear();

      if (optionButtons.length > 0) {
        const firstButton = optionButtons[0];
        firstButton.classList.add('selected');
        selectedCategory = firstButton.dataset.label;
        if (selectedInput) selectedInput.value = selectedCategory;
        updateSectionVisibility(selectedCategory);
        updateMeasurementsForCategory(selectedCategory);
      }

      if (addToCartButton) {
        addToCartButton.disabled = true;
        addToCartButton.style.opacity = '0.5';
      }
      updateAddToCartButton();
    }

    function updateBannerVisibility() {
      const banner = document.getElementById('order-status-banner');
      if (!banner) return;

      if (
        window.location.pathname.includes('/checkouts/') ||
        window.location.pathname.includes('/thank-you') ||
        window.location.pathname.includes('/checkout')
      ) {
        banner.style.display = 'none';
        return;
      }

      if (window.location.pathname.includes('/products/')) {
        banner.style.display = 'block';
        return;
      }

      if (window.location.pathname.includes('/cart')) {
        fetch('/cart.js')
          .then((response) => response.json())
          .then((cart) => {
            banner.style.display = cart.item_count > 0 ? 'block' : 'none';
          })
          .catch(() => {
            banner.style.display = 'block';
          });
      }
    }

    optionButtons.forEach((button) => {
      button.addEventListener('click', function () {
        optionButtons.forEach((btn) => btn.classList.remove('selected'));
        this.classList.add('selected');
        selectedCategory = this.dataset.label;
        if (selectedInput) selectedInput.value = selectedCategory;

        updateSectionVisibility(selectedCategory);
        updateMeasurementsForCategory(selectedCategory);
        updateMeasurementOnUnitChange();
        updateAddToCartButton();
      });
    });

    unitToggleButtons.forEach((button) => {
      button.addEventListener('click', function () {
        currentUnit = this.dataset.unit;
        unitToggleButtons.forEach((btn) => {
          btn.classList.toggle('active', btn.dataset.unit === currentUnit);
        });

        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        updateMeasurementOnUnitChange();
      });
    });

    measurementInputs.forEach((input) => {
      input.addEventListener('input', function () {
        const field = this.closest('.measurement-field');
        if (!field) return;
        const measName = field.dataset.measurement;
        const unit = this.classList.contains('measurement-in') ? 'in' : 'cm';
        const numericValue = parseValue(this.value);

        if (Number.isFinite(numericValue)) {
          syncMeasurementValues(measName, unit, numericValue);
        } else if (!isSyncingValues) {
          const targetInput =
            unit === 'in' ? field.querySelector('.measurement-cm') : field.querySelector('.measurement-in');
          if (targetInput) {
            targetInput.value = '';
          }
          measurementValues.delete(measName);
        }

        updateAddToCartButton();
      });
    });

    harnessSelects.forEach((select) => {
      select.addEventListener('change', updateAddToCartButton);
    });

    harnessCustomTexts.forEach((input) => {
      input.addEventListener('input', updateAddToCartButton);
    });

    if (productForm) {
      productForm.addEventListener('submit', function (event) {
        if (!validateRequiredFields()) {
          event.preventDefault();
          alert('Please select a category and fill all required measurements.');
          return false;
        }

        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        document.querySelectorAll('.measurement-field.active').forEach((field) => {
          const measName = field.dataset.measurement;
          const inInput = field.querySelector('.measurement-in');
          const cmInput = field.querySelector('.measurement-cm');
          const inValue = parseValue(inInput ? inInput.value : '');
          const cmValue = parseValue(cmInput ? cmInput.value : '');

          if (Number.isFinite(inValue) && !Number.isFinite(cmValue)) {
            syncMeasurementValues(measName, 'in', inValue);
          } else if (Number.isFinite(cmValue) && !Number.isFinite(inValue)) {
            syncMeasurementValues(measName, 'cm', cmValue);
          }
        });

        if (selectedCategory && config.measurements) {
          const measurementInputsForSubmit = this.querySelectorAll('input[name^="properties["]');
          measurementInputsForSubmit.forEach((input) => {
            const name = input.getAttribute('name');
            if (!name || (!name.includes('(in)') && !name.includes('(cm)'))) return;

            const match = name.match(/properties\[(.+?)\s+\(in\)\]|properties\[(.+?)\s+\(cm\)\]/);
            if (!match) return;

            const measName = match[1] || match[2];
            const measConfig = config.measurements[measName];
            const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[selectedCategory] : null;
            const isIncluded = categoryInfo && categoryInfo.included === true;
            const value = input.value && input.value.trim() !== '' ? input.value : '';

            if (!isIncluded || value === '') {
              input.removeAttribute('name');
              input.setAttribute('data-removed', 'true');
            }
          });
        }
      });
    }

    function delayedInitialize() {
      initialize();
      updateAddToCartButton();
      updateBannerVisibility();
    }

    window.addEventListener('pageshow', function () {
      initialize();
      updateAddToCartButton();
      updateBannerVisibility();
    });

    document.addEventListener('cart:updated', updateBannerVisibility);

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', delayedInitialize);
    } else {
      delayedInitialize();
    }
  })();

  function toggleCustomFields() {
    document.querySelectorAll('.custom-text').forEach((el) => {
      el.style.display = 'block';
    });
  }
</script>
