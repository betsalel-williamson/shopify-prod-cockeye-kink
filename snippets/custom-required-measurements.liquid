{% comment %}
  Custom Required Measurements Snippet
  Configuration is driven by theme settings: categories are pipe-delimited and
  measurements are mapped via a text area using the format
  "Measurement: Category, Category*, ...".
{% endcomment %}

{%- assign default_categories_order = 'Deluxe Harness|Standard Harness|Suspender Harness|Dogtag/Pigtag|Chaps|Shirt|Pants|Suspenders|Other' -%}
{%- assign categories_order = settings.custom_measurements_categories_order
  | default: default_categories_order
  | split: '|'
-%}

{%- assign default_measurement_map = 'Neck: Deluxe Harness, Standard Harness, Suspender Harness, Dogtag/Pigtag*, Other*\nChest: Deluxe Harness, Standard Harness, Suspender Harness, Shirt, Suspenders, Other*\nShoulders: Deluxe Harness, Standard Harness, Suspender Harness, Shirt, Suspenders, Other*\nTorso: Deluxe Harness, Standard Harness, Suspender Harness, Shirt, Other*\nStomach: Shirt, Other*\nWaist: Deluxe Harness, Standard Harness, Suspender Harness, Chaps, Pants, Suspenders, Other*\nButt: Pants, Other*\nButt Rise: Pants, Other*\nUpper Thigh: Chaps, Pants, Other*\nLower Thigh: Chaps, Pants, Other*\nKnee: Chaps, Pants, Other*\nCalf: Chaps, Pants, Other*\nAnkle: Chaps, Pants, Other*\nInseam: Pants, Other*\nCrotch: Pants, Other*\nBicep: Shirt, Other*\nHips: Chaps*, Pants*, Other*' -%}
{%- assign measurement_map_source = settings.custom_measurements_map | default: default_measurement_map -%}
{%- assign measurement_map_lines = measurement_map_source | newline_to_br | split: '<br />' -%}

{%- assign measurement_names = '' | split: '|' -%}
{%- for measurement_line in measurement_map_lines -%}
  {%- assign measurement_line = measurement_line | strip -%}
  {%- if measurement_line == '' -%}{% continue %}{% endif %}
  {%- assign parts = measurement_line | split: ':' -%}
  {%- assign measurement_label = parts[0] | strip -%}
  {%- if measurement_label == '' -%}{% continue %}{% endif %}
  {%- assign measurement_entry = measurement_label | split: '__split__' -%}
  {%- assign measurement_names = measurement_names | concat: measurement_entry -%}
{%- endfor -%}
{%- assign measurement_names = measurement_names | uniq -%}

{%- assign harness_categories = settings.custom_measurements_harness_categories
  | default: 'Deluxe Harness|Standard Harness|Suspender Harness'
  | split: '|'
-%}
{%- assign leather_colors = settings.custom_measurements_leather_colors
  | default: 'Black|White|Red|Blue|Green|Yellow|Orange|Purple'
  | split: '|'
-%}
{%- assign front_plate_options = settings.custom_measurements_front_plate_options
  | default: 'Bear Paw|Puppy Paw|Fist Image|Pig Image|Boot Image|Biohazard Symbol|Cigar Man'
  | split: '|'
-%}
{%- assign back_plate_extra = settings.custom_measurements_back_plate_extra
  | default: 'Wesco Boot|Watersports|Happy Puppy'
  | split: '|'
-%}
{%- assign back_plate_options = front_plate_options | concat: back_plate_extra -%}
{%- assign left_front_plates = front_plate_options -%}
{%- assign right_front_plates = front_plate_options -%}
{%- assign back_plates = back_plate_options -%}
{%- assign long_sliders = settings.custom_measurements_long_sliders | default: 'None|Brass|Steel' | split: '|' -%}

{%- liquid
  assign order_tag_name = '_custom'
  assign order_tag_value = 'custom'
-%}

<style>
  .unit-toggle-container {
    display: flex;
    align-items: center;
    gap: var(--spacing-3, 0.75rem);
    margin-bottom: var(--spacing-4, 1.5rem);
    padding: var(--spacing-2, 0.5rem) var(--spacing-3, 0.75rem);
    background-color: rgba(var(--color-foreground-rgb, 0, 0, 0), 0.04);
    border-radius: var(--border-radius-base, 0.5rem);
  }

  .unit-toggle-label {
    font-weight: var(--font-heading-weight, 600);
    margin-right: var(--spacing-2, 0.5rem);
  }

  .unit-toggle-buttons {
    display: flex;
    gap: var(--spacing-2, 0.5rem);
  }

  .unit-toggle-button.button--secondary.active {
    background-color: var(--color-foreground);
    color: var(--color-background);
    border-color: var(--color-foreground);
  }

  .measurement-input {
    font-weight: var(--font-body-weight-bold, 600);
    color: var(--color-foreground);
    width: 6em;
  }

  .measurements-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: var(--spacing-3, 0.75rem);
    margin-bottom: var(--spacing-4, 1.5rem);
  }

  .measurements-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: var(--font-heading-weight, 600);
  }

  .measurement-field {
    display: none;
  }

  .measurement-field.active {
    display: block;
  }

  .conditional-section {
    display: none;
    margin-top: var(--spacing-4, 1.5rem);
    padding: var(--spacing-3, 0.75rem);
    background-color: rgba(var(--color-foreground-rgb, 0, 0, 0), 0.04);
    border-radius: var(--border-radius-base, 0.5rem);
  }

  .conditional-section.active {
    display: block;
  }

  .conditional-section label {
    display: block;
    margin-top: var(--spacing-3, 0.75rem);
    margin-bottom: 0.25rem;
    font-weight: var(--font-heading-weight, 600);
  }

  .conditional-section label:first-child {
    margin-top: 0;
  }

  .conditional-section select,
  .conditional-section .custom-text {
    width: 100%;
    margin-bottom: var(--spacing-2, 0.5rem);
  }

  .custom-text {
    margin-top: var(--spacing-2, 0.5rem);
    display: none;
  }

  .custom-toggle-button {
    margin-top: var(--spacing-3, 0.75rem);
  }

  .measurement-hint {
    margin-bottom: var(--spacing-3, 0.75rem);
    font-size: 0.92em;
    color: rgba(var(--color-foreground-rgb, 0, 0, 0), 0.7);
  }

  .measurement-field--optional label {
    font-weight: var(--font-body-weight, 400);
  }
</style>

{%- comment -%} Category Selection Buttons {%- endcomment -%}
<fieldset class="product-form__input product-form__input--pill" id="optionButtons">
  <legend class="form__label">Custom product category</legend>
  {%- for category in categories_order -%}
    {%- assign category_name = category | strip -%}
    {%- if category_name == '' -%}{% continue %}{% endif %}
    {%- assign required_list = '' | split: '|' -%}
    {%- assign optional_list = '' | split: '|' -%}

    {%- for measurement_line in measurement_map_lines -%}
      {%- assign measurement_line = measurement_line | strip -%}
      {%- if measurement_line == '' -%}{% continue %}{% endif %}
      {%- assign parts = measurement_line | split: ':' -%}
      {%- assign measurement_label = parts[0] | strip -%}
      {%- if measurement_label == '' -%}{% continue %}{% endif %}
      {%- assign categories_part = '' -%}
      {%- if parts.size > 1 -%}
        {%- assign categories_part = parts[1] -%}
      {%- endif -%}
      {%- assign category_tokens = categories_part | split: ',' -%}
      {%- for token in category_tokens -%}
        {%- assign token_clean = token | strip -%}
        {%- if token_clean == '' -%}{% continue %}{% endif %}
        {%- assign base_category = token_clean | remove: '*' | strip -%}
        {%- if base_category == category_name -%}
          {%- assign measurement_entry = measurement_label | split: '__split__' -%}
          {%- if base_category != token_clean -%}
            {%- assign optional_list = optional_list | concat: measurement_entry -%}
          {%- else -%}
            {%- assign required_list = required_list | concat: measurement_entry -%}
          {%- endif -%}
        {%- endif -%}
      {%- endfor -%}
    {%- endfor -%}

    {%- assign required_string = required_list | uniq | join: '|' -%}
    {%- assign optional_string = optional_list | uniq | join: '|' -%}

    {%- assign harness_match = false -%}
    {%- for harness in harness_categories -%}
      {%- assign harness_clean = harness | strip -%}
      {%- if harness_clean == category_name -%}
        {%- assign harness_match = true -%}
        {%- break -%}
      {%- endif -%}
    {%- endfor -%}

    {%- assign option_id = 'custom-category-' | append: section.id | append: '-' | append: forloop.index0 -%}
    <input
      type="radio"
      id="{{ option_id }}"
      class="category-option-input"
      name="properties[Selected Option]"
      value="{{ category_name }}"
      data-index="{{ forloop.index0 }}"
      data-label="{{ category_name }}"
      data-required="{{ required_string }}"
      data-optional="{{ optional_string }}"
      data-show-harness="{% if harness_match %}true{% else %}false{% endif %}"
      data-show-notes="true"
      {% if forloop.first %}checked{% endif %}
    >
    <label class="category-option-label" for="{{ option_id }}">
      {{ category_name }}
    </label>
  {%- endfor -%}
</fieldset>

{%- comment -%} Unit of Measure - First property to indicate measurement unit used {%- endcomment -%}
<input
  type="hidden"
  id="unitOfMeasure"
  name="properties[Unit of Measure]"
  value="Measured in Inches"
  form="product-form-{{ section.id }}"
>

{%- comment -%} Custom Order Tagging {%- endcomment -%}
<input
  type="hidden"
  name="properties[{{ order_tag_name }}]"
  value="{{ order_tag_value }}"
  form="product-form-{{ section.id }}"
>

{%- comment -%} Unit Toggle {%- endcomment -%}
<fieldset class="product-form__input product-form__input--pill unit-toggle" id="unitToggle">
  <legend class="form__label">Unit</legend>
  <label>
    <input type="radio" name="unit_toggle" value="in" data-unit="in" checked>
    Inches
  </label>
  <label>
    <input type="radio" name="unit_toggle" value="cm" data-unit="cm">
    Centimeters
  </label>
</fieldset>

{%- comment -%} Measurement Fields {%- endcomment -%}
<p class="measurement-hint">Measurements marked with * are optional for the selected category.</p>
<div class="measurements-group" id="measurementsGroup">
  {%- for meas_name in measurement_names -%}
    {%- assign measurement_label = meas_name | strip -%}
    {%- if measurement_label == '' -%}{% continue %}{% endif %}
    {%- assign handle = measurement_label | handleize -%}
    <div
      class="measurement-field"
      id="measurement-{{ handle }}"
      data-measurement="{{ measurement_label }}"
      data-label-base="{{ measurement_label }}"
    >
      <label for="{{ handle }}-in">{{ measurement_label }}</label>
      <input
        type="number"
        inputmode="decimal"
        autocomplete="off"
        id="{{ handle }}-in"
        name="properties[{{ measurement_label }} (in)]"
        form="product-form-{{ section.id }}"
        class="measurement-input measurement-in"
        data-measurement="{{ measurement_label }}"
        placeholder="0.000"
      >
      <input
        type="number"
        inputmode="decimal"
        autocomplete="off"
        id="{{ handle }}-cm"
        name="properties[{{ measurement_label }} (cm)]"
        form="product-form-{{ section.id }}"
        class="measurement-input measurement-cm"
        data-measurement="{{ measurement_label }}"
        placeholder="0.000"
        style="display: none;"
      >
    </div>
  {%- endfor -%}
</div>

{%- comment -%} Harness Details Section {%- endcomment -%}
<div class="conditional-section" id="harness-details">
  <label>Leather Color</label>
  <select name="properties[Leather Color]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for color in leather_colors -%}
      <option>{{ color }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Leather Color - Text]"
    class="custom-text"
    placeholder="Enter custom color"
    form="product-form-{{ section.id }}"
  >

  <label>Left Front Plate</label>
  <select name="properties[Left Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in left_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Left Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Right Front Plate</label>
  <select name="properties[Right Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in right_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Right Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Back Plate</label>
  <select name="properties[Back Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in back_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Back Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Long Sliders</label>
  <select name="properties[Long Sliders]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for slider in long_sliders -%}
      <option>{{ slider }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Long Sliders - Text]"
    class="custom-text"
    placeholder="Enter custom sliders"
    form="product-form-{{ section.id }}"
  >

  <div>
    <button type="button" class="custom-toggle-button button button--secondary" onclick="toggleCustomFields()">
      Don't see a color listed? Click here
    </button>
  </div>
</div>

{%- comment -%} Notes Section {%- endcomment -%}
<div class="conditional-section" id="notes-section">
  <label>Item Notes *</label>
  <textarea
    name="properties[Item Notes]"
    placeholder="Enter your item notes here"
    form="product-form-{{ section.id }}"
  ></textarea>
  <label>Event Notes *</label>
  <textarea
    name="properties[Event Notes]"
    placeholder="Event name or notes here"
    form="product-form-{{ section.id }}"
  ></textarea>
</div>

<script>
  (function () {
    'use strict';

    const categoryInputs = Array.from(document.querySelectorAll('.category-option-input'));
    const measurementFields = Array.from(document.querySelectorAll('.measurement-field'));
    const measurementNames = measurementFields.map((field) => field.dataset.measurement);

    const categoryConfigs = {};
    const harnessDetailCategories = [];

    categoryInputs.forEach((input) => {
      const categoryName = input.dataset.label;
      const requiredList = (input.dataset.required || '').split('|').filter(Boolean);
      const optionalList = (input.dataset.optional || '').split('|').filter(Boolean);
      categoryConfigs[categoryName] = {
        required: requiredList,
        optional: optionalList,
      };
      if (input.dataset.showHarness === 'true') {
        harnessDetailCategories.push(categoryName);
      }
    });

    const measurements = {};
    measurementNames.forEach((measName) => {
      const categoryInfo = {};
      Object.entries(categoryConfigs).forEach(([categoryName, categoryConfig]) => {
        if (categoryConfig.required.includes(measName)) {
          categoryInfo[categoryName] = { included: true, required: true };
        } else if (categoryConfig.optional.includes(measName)) {
          categoryInfo[categoryName] = { included: true, required: false };
        }
      });
      measurements[measName] = { categories: categoryInfo };
    });

    const config = {
      measurements,
      categories: {
        harness_details: harnessDetailCategories,
        notes_section: [],
      },
    };

    const INCH_TO_CM = 2.54;
    const CM_TO_INCH = 1 / 2.54;
    const PRECISION = 3;

    let currentUnit = 'in';
    let selectedCategory = null;
    const measurementValues = new Map();
    let isSyncingValues = false;
    let hasInteractedWithForm = false;

    const measurementInputs = document.querySelectorAll('.measurement-input');
    const harnessSection = document.getElementById('harness-details');
    const notesSection = document.getElementById('notes-section');
    const unitToggleInputs = document.querySelectorAll('#unitToggle input[type="radio"]');

    const productFormSelectors = [
      '#product-form-{{ section.id }}',
      'form[action*="/cart/add"]',
      'form[id^="product-form"]',
    ];
    let productForm = null;
    for (const selector of productFormSelectors) {
      const formCandidate = document.querySelector(selector);
      if (formCandidate) {
        productForm = formCandidate;
        break;
      }
    }

    const unitOfMeasureInput = document.getElementById('unitOfMeasure');
    const harnessSelects = document.querySelectorAll('#harness-details select');
    const harnessCustomTexts = document.querySelectorAll('#harness-details .custom-text');

    const buttonId = 'ProductSubmitButton-{{ section.id }}';
    let addToCartButton = null;
    let addToCartButtonWarningLogged = false;
    let addToCartButtonListenerAttached = false;
    let resetAfterAddToCartPending = false;

    function resolveAddToCartButton() {
      if (addToCartButton && document.body.contains(addToCartButton)) {
        return addToCartButton;
      }

      const buttonSelectors = [
        `#${buttonId}`,
        `#product-form-{{ section.id }} button[type="submit"]`,
        `#product-form-{{ section.id }} button[name="add"]`,
        'form[action*="/cart/add"] button[type="submit"]',
        'form[action*="/cart/add"] button[name="add"]',
        'button[name="add"][type="submit"]',
      ];

      for (const selector of buttonSelectors) {
        const candidate = document.querySelector(selector);
        if (candidate) {
          addToCartButton = candidate;
          if (!addToCartButtonListenerAttached) {
            addToCartButton.addEventListener('click', function () {
              resetAfterAddToCartPending = true;
            });
            addToCartButtonListenerAttached = true;
          }
          return addToCartButton;
        }
      }

      if (!addToCartButtonWarningLogged) {
        console.warn('Could not find add to cart button with ID:', buttonId);
        addToCartButtonWarningLogged = true;
      }

      return null;
    }

    function updateBannerEditingState(isEditing) {
      const eventName = isEditing ? 'custom-order:editing' : 'custom-order:editing-stop';
      try {
        window.dispatchEvent(new CustomEvent(eventName));
      } catch (error) {
        console.warn('Unable to dispatch banner editing event:', error);
      }
      if (window.CustomOrderBanner && typeof window.CustomOrderBanner.notifyEditing === 'function') {
        window.CustomOrderBanner.notifyEditing(isEditing);
      }
    }

    function flagFormInteraction() {
      if (hasInteractedWithForm) return;
      hasInteractedWithForm = true;
      updateBannerEditingState(true);
    }

    function formatValue(value) {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return '';
      }
      return Number(value).toFixed(PRECISION);
    }

    function parseValue(raw) {
      if (typeof raw !== 'string') return NaN;
      const trimmed = raw.trim();
      if (trimmed === '') return NaN;
      const parsed = Number(trimmed);
      return Number.isFinite(parsed) ? parsed : NaN;
    }

    function hasValidNumber(input) {
      if (!input) return false;
      return Number.isFinite(parseValue(input.value));
    }

    function clearMeasurementField(field) {
      const inInput = field.querySelector('.measurement-in');
      const cmInput = field.querySelector('.measurement-cm');
      if (inInput) inInput.value = '';
      if (cmInput) cmInput.value = '';
      measurementValues.delete(field.dataset.measurement);
    }

    function updateMeasurementVisibility() {
      measurementFields.forEach((field) => {
        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');
        if (!inInput || !cmInput) return;
        if (currentUnit === 'in') {
          inInput.style.display = 'block';
          cmInput.style.display = 'none';
        } else {
          inInput.style.display = 'none';
          cmInput.style.display = 'block';
        }
      });
    }

    function syncMeasurementValues(measName, sourceUnit, numericValue) {
      const field = document.querySelector(`.measurement-field[data-measurement="${measName}"]`);
      if (!field) return;
      const inInput = field.querySelector('.measurement-in');
      const cmInput = field.querySelector('.measurement-cm');
      if (!inInput || !cmInput) return;

      if (isSyncingValues) return;
      isSyncingValues = true;

      if (sourceUnit === 'in') {
        if (inInput.value !== formatValue(numericValue)) {
          inInput.value = formatValue(numericValue);
        }
        const converted = numericValue * INCH_TO_CM;
        cmInput.value = formatValue(converted);
        measurementValues.set(measName, { in: numericValue, cm: converted });
      } else {
        if (cmInput.value !== formatValue(numericValue)) {
          cmInput.value = formatValue(numericValue);
        }
        const converted = numericValue * CM_TO_INCH;
        inInput.value = formatValue(converted);
        measurementValues.set(measName, { in: converted, cm: numericValue });
      }

      isSyncingValues = false;
    }

    function updateMeasurementsForCategory(category) {
      measurementFields.forEach((field) => {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];
        const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[category] : null;
        const baseLabel = field.dataset.labelBase || measName;
        const labelElement = field.querySelector('label');

        if (categoryInfo && categoryInfo.included) {
          field.classList.add('active');
          const isOptional = categoryInfo.required === false;
          field.classList.toggle('measurement-field--optional', isOptional);
          field.dataset.optional = isOptional ? 'true' : 'false';
          if (labelElement) {
            labelElement.textContent = isOptional ? `${baseLabel} *` : baseLabel;
          }
        } else {
          field.classList.remove('active');
          field.classList.remove('measurement-field--optional');
          field.removeAttribute('data-optional');
          if (labelElement) {
            labelElement.textContent = baseLabel;
          }
          clearMeasurementField(field);
        }
      });
    }

    function validateRequiredFields() {
      if (!selectedCategory || !config.measurements) return false;

      const activeFields = document.querySelectorAll('.measurement-field.active');
      for (const field of activeFields) {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];
        if (!measConfig) continue;

        const categoryInfo = measConfig.categories ? measConfig.categories[selectedCategory] : null;
        if (!categoryInfo || !categoryInfo.required) continue;

        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');
        const hasValue = hasValidNumber(inInput) || hasValidNumber(cmInput);
        if (!hasValue) {
          return false;
        }
      }

      if (harnessSection && harnessSection.classList.contains('active')) {
        const harnessFields = [
          'properties[Leather Color]',
          'properties[Left Front Plate]',
          'properties[Right Front Plate]',
          'properties[Back Plate]',
          'properties[Long Sliders]',
        ];

        for (const fieldName of harnessFields) {
          const select = document.querySelector(`select[name="${fieldName}"]`);
          if (!select) continue;
          const selectedOption = select.options[select.selectedIndex];
          const hasSelectValue =
            selectedOption &&
            selectedOption.value !== '' &&
            selectedOption.value !== null &&
            selectedOption.value !== 'Select one';

          const customTextName = fieldName.replace(']', ' - Text]');
          const customText = document.querySelector(`input[name="${customTextName}"]`);
          const hasCustomText = customText && customText.value && customText.value.trim() !== '';

          if (!hasSelectValue && !hasCustomText) {
            return false;
          }
        }
      }

      return true;
    }

    function updateAddToCartButton() {
      const button = resolveAddToCartButton();
      if (!button) return;

      const isValid = validateRequiredFields();
      if (!isValid) {
        button.disabled = true;
        button.style.opacity = '0.5';
        button.setAttribute('disabled', 'disabled');
        button.setAttribute('aria-disabled', 'true');
        button.title = 'Please select a category and fill all required measurements';
      } else {
        button.disabled = false;
        button.style.opacity = '1';
        button.removeAttribute('disabled');
        button.removeAttribute('aria-disabled');
        button.removeAttribute('title');
      }
    }

    function updateSectionVisibility(category) {
      if (harnessSection) {
        const showHarness =
          config.categories && config.categories.harness_details
            ? config.categories.harness_details.includes(category)
            : false;
        harnessSection.classList.toggle('active', showHarness);
      }
      if (notesSection) {
        notesSection.classList.add('active');
      }

      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });
    }

    function updateMeasurementOnUnitChange() {
      const activeFields = document.querySelectorAll('.measurement-field.active');
      activeFields.forEach((field) => {
        const measName = field.dataset.measurement;
        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');

        if (!inInput || !cmInput) return;

        if (currentUnit === 'in') {
          const cmValue = parseValue(cmInput.value);
          if (Number.isFinite(cmValue)) {
            syncMeasurementValues(measName, 'cm', cmValue);
          }
        } else {
          const inValue = parseValue(inInput.value);
          if (Number.isFinite(inValue)) {
            syncMeasurementValues(measName, 'in', inValue);
          }
        }
      });

      updateMeasurementVisibility();
      updateAddToCartButton();
    }

    function initialize() {
      hasInteractedWithForm = false;
      updateBannerEditingState(false);
      resetAfterAddToCartPending = false;

      if (unitOfMeasureInput) {
        unitOfMeasureInput.value = 'Measured in Inches';
      }

      selectedCategory = null;

      if (harnessSection) harnessSection.classList.remove('active');
      if (notesSection) notesSection.classList.remove('active');

      measurementFields.forEach((field) => {
        clearMeasurementField(field);
        field.classList.remove('active');
      });

      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });

      currentUnit = 'in';
      unitToggleInputs.forEach((input) => {
        input.checked = input.dataset.unit === 'in';
      });
      updateMeasurementVisibility();

      measurementValues.clear();

      if (categoryInputs.length > 0) {
        const firstInput = categoryInputs[0];
        firstInput.checked = true;
        selectedCategory = firstInput.dataset.label;
        updateSectionVisibility(selectedCategory);
        updateMeasurementsForCategory(selectedCategory);
      }

      const button = resolveAddToCartButton();
      if (button) {
        button.disabled = true;
        button.style.opacity = '0.5';
      }
      updateAddToCartButton();
    }

    categoryInputs.forEach((input) => {
      input.addEventListener('change', function () {
        if (!this.checked) return;
        flagFormInteraction();
        selectedCategory = this.dataset.label;

        updateSectionVisibility(selectedCategory);
        updateMeasurementsForCategory(selectedCategory);
        updateMeasurementOnUnitChange();
        updateAddToCartButton();
      });
    });

    unitToggleInputs.forEach((input) => {
      input.addEventListener('change', function () {
        if (!this.checked) return;
        flagFormInteraction();
        currentUnit = this.dataset.unit;

        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        updateMeasurementOnUnitChange();
      });
    });

    measurementInputs.forEach((input) => {
      input.addEventListener('input', function () {
        flagFormInteraction();
        updateAddToCartButton();
      });

      function normalizeMeasurementValue() {
        const field = input.closest('.measurement-field');
        if (!field) return;
        const measName = field.dataset.measurement;
        const unit = input.classList.contains('measurement-in') ? 'in' : 'cm';
        const numericValue = parseValue(input.value);

        if (Number.isFinite(numericValue)) {
          syncMeasurementValues(measName, unit, numericValue);
        } else if (!isSyncingValues) {
          const targetInput =
            unit === 'in' ? field.querySelector('.measurement-cm') : field.querySelector('.measurement-in');
          if (targetInput) {
            targetInput.value = '';
          }
          measurementValues.delete(measName);
        }
        updateAddToCartButton();
      }

      input.addEventListener('blur', normalizeMeasurementValue);
      input.addEventListener('change', normalizeMeasurementValue);
    });

    harnessSelects.forEach((select) => {
      select.addEventListener('change', updateAddToCartButton);
      select.addEventListener('change', flagFormInteraction);
    });

    harnessCustomTexts.forEach((input) => {
      input.addEventListener('input', function () {
        flagFormInteraction();
        updateAddToCartButton();
      });
    });

    if (productForm) {
      productForm.addEventListener('submit', function (event) {
        if (!validateRequiredFields()) {
          event.preventDefault();
          alert('Please select a category and fill all required measurements.');
          resetAfterAddToCartPending = false;
          return false;
        }

        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        document.querySelectorAll('.measurement-field.active').forEach((field) => {
          const measName = field.dataset.measurement;
          const inInput = field.querySelector('.measurement-in');
          const cmInput = field.querySelector('.measurement-cm');
          const inValue = parseValue(inInput ? inInput.value : '');
          const cmValue = parseValue(cmInput ? cmInput.value : '');

          if (Number.isFinite(inValue) && !Number.isFinite(cmValue)) {
            syncMeasurementValues(measName, 'in', inValue);
          } else if (Number.isFinite(cmValue) && !Number.isFinite(inValue)) {
            syncMeasurementValues(measName, 'cm', cmValue);
          }
        });

        if (selectedCategory && config.measurements) {
          const measurementInputsForSubmit = this.querySelectorAll('input[name^="properties["]');
          measurementInputsForSubmit.forEach((input) => {
            const name = input.getAttribute('name');
            if (!name || (!name.includes('(in)') && !name.includes('(cm)'))) return;

            const match = name.match(/properties\[(.+?)\s+\(in\)\]|properties\[(.+?)\s+\(cm\)\]/);
            if (!match) return;

            const measName = match[1] || match[2];
            const measConfig = config.measurements[measName];
            const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[selectedCategory] : null;
            const isIncluded = categoryInfo && categoryInfo.included === true;
            const value = input.value && input.value.trim() !== '' ? input.value : '';

            if (!isIncluded || value === '') {
              input.removeAttribute('name');
              input.setAttribute('data-removed', 'true');
            }
          });
        }

        resetAfterAddToCartPending = true;
        hasInteractedWithForm = false;
        updateBannerEditingState(false);
      });
    }

    function delayedInitialize() {
      initialize();
      updateAddToCartButton();
    }

    window.addEventListener('pageshow', function () {
      initialize();
      updateAddToCartButton();
    });

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', delayedInitialize);
    } else {
      delayedInitialize();
    }

    document.addEventListener('cart:updated', function () {
      hasInteractedWithForm = false;
      updateBannerEditingState(false);
      if (resetAfterAddToCartPending) {
        initialize();
        updateAddToCartButton();
        resetAfterAddToCartPending = false;
      }
    });
  })();

  function toggleCustomFields() {
    document.querySelectorAll('.custom-text').forEach((el) => {
      el.style.display = 'block';
    });
  }
</script>
