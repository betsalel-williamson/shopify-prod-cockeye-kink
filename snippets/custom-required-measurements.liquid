{% comment %}
  Custom Required Measurements Snippet
  Configuration is driven by theme settings: categories are pipe-delimited and
  measurements are mapped via a text area using the format
  "Measurement: Category, Category*, ...".
{% endcomment %}

{%- assign default_categories_order = 'Deluxe Harness|Standard Harness|Suspender Harness|Dogtag/Pigtag|Chaps|Shirt|Pants|Suspenders|Other' -%}
{%- assign categories_order = settings.custom_measurements_categories_order
  | default: default_categories_order
  | split: '|'
-%}

{%- assign default_measurement_map = 'Neck: Deluxe Harness, Standard Harness, Suspender Harness, Dogtag/Pigtag*, Other*\nChest: Deluxe Harness, Standard Harness, Suspender Harness, Shirt, Suspenders, Other*\nShoulders: Deluxe Harness, Standard Harness, Suspender Harness, Shirt, Suspenders, Other*\nTorso: Deluxe Harness, Standard Harness, Suspender Harness, Shirt, Other*\nStomach: Shirt, Other*\nWaist: Deluxe Harness, Standard Harness, Suspender Harness, Chaps, Pants, Suspenders, Other*\nButt: Pants, Other*\nButt Rise: Pants, Other*\nUpper Thigh: Chaps, Pants, Other*\nLower Thigh: Chaps, Pants, Other*\nKnee: Chaps, Pants, Other*\nCalf: Chaps, Pants, Other*\nAnkle: Chaps, Pants, Other*\nInseam: Pants, Other*\nCrotch: Pants, Other*\nBicep: Shirt, Other*\nHips: Chaps*, Pants*, Other*' -%}
{%- assign measurement_map_source = settings.custom_measurements_map | default: default_measurement_map -%}
{%- assign measurement_map_lines = measurement_map_source | newline_to_br | split: '<br />' -%}

{%- assign measurement_names = '' | split: '|' -%}
{%- for measurement_line in measurement_map_lines -%}
  {%- assign measurement_line = measurement_line | strip -%}
  {%- if measurement_line == '' -%}{% continue %}{% endif %}
  {%- assign parts = measurement_line | split: ':' -%}
  {%- assign measurement_label = parts[0] | strip -%}
  {%- if measurement_label == '' -%}{% continue %}{% endif %}
  {%- assign measurement_entry = measurement_label | split: '__split__' -%}
  {%- assign measurement_names = measurement_names | concat: measurement_entry -%}
{%- endfor -%}
{%- assign measurement_names = measurement_names | uniq -%}

{%- assign harness_categories = settings.custom_measurements_harness_categories
  | default: 'Deluxe Harness|Standard Harness|Suspender Harness'
  | split: '|'
-%}
{%- assign notes_categories = settings.custom_measurements_notes_categories
  | default: 'Dogtag/Pigtag|Chaps|Shirt|Pants|Suspenders|Other'
  | split: '|'
-%}

{%- assign leather_colors = settings.custom_measurements_leather_colors
  | default: 'Black|White|Red|Blue|Green|Yellow|Orange|Purple'
  | split: '|'
-%}
{%- assign front_plate_options = settings.custom_measurements_front_plate_options
  | default: 'Bear Paw|Puppy Paw|Fist Image|Pig Image|Boot Image|Biohazard Symbol|Cigar Man'
  | split: '|'
-%}
{%- assign back_plate_extra = settings.custom_measurements_back_plate_extra
  | default: 'Wesco Boot|Watersports|Happy Puppy'
  | split: '|'
-%}
{%- assign back_plate_options = front_plate_options | concat: back_plate_extra -%}
{%- assign left_front_plates = front_plate_options -%}
{%- assign right_front_plates = front_plate_options -%}
{%- assign back_plates = back_plate_options -%}
{%- assign long_sliders = settings.custom_measurements_long_sliders | default: 'None|Brass|Steel' | split: '|' -%}

{%- liquid
  assign order_tag_name = '_custom'
  assign order_tag_value = 'custom'
-%}

<style>
  .unit-toggle-container {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    padding: 8px 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
  }

  .unit-toggle-label {
    font-weight: bold;
    margin-right: 8px;
  }

  .unit-toggle-buttons {
    display: flex;
    gap: 8px;
  }

  .unit-toggle-button {
    padding: 6px 16px;
    border: 2px solid #ccc;
    border-radius: 6px;
    background-color: white;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
  }

  .unit-toggle-button.active {
    background-color: #444;
    color: #fff;
    border-color: #444;
  }

  .measurement-input {
    font-weight: bold;
    color: black;
    width: 6em;
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
  }

  .measurements-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;
    margin-bottom: 16px;
  }

  .measurements-group label {
    display: block;
    margin-bottom: 4px;
    font-weight: bold;
  }

  .measurement-field {
    display: none;
  }

  .measurement-field.active {
    display: block;
  }

  .options-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 16px;
  }

  .option-button {
    background-color: #eee;
    border: 2px solid #ccc;
    border-radius: 8px;
    padding: 10px 18px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .option-button.selected {
    background-color: #444;
    color: #fff;
  }

  .conditional-section {
    display: none;
    margin-top: 16px;
    padding: 10px;
    background-color: #f9f9f9;
    border-radius: 8px;
  }

  .conditional-section.active {
    display: block;
  }

  .conditional-section label {
    display: block;
    margin-top: 12px;
    margin-bottom: 4px;
    font-weight: bold;
  }

  .conditional-section label:first-child {
    margin-top: 0;
  }

  .conditional-section select {
    display: block;
    width: 100%;
    margin-bottom: 8px;
  }

  .conditional-section .custom-text {
    display: block;
    width: 100%;
    margin-top: 8px;
    margin-bottom: 8px;
  }

  .custom-text {
    margin-top: 8px;
    display: none;
  }

  .custom-toggle-button {
    display: inline-block;
    margin-top: 12px;
    background-color: #ccc;
    padding: 8px 14px;
    font-weight: bold;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .custom-toggle-button:hover {
    background-color: #aaa;
  }
</style>

{%- comment -%} Category Selection Buttons {%- endcomment -%}
<div class="options-group" id="optionButtons">
  {%- for category in categories_order -%}
    {%- assign category_name = category | strip -%}
    {%- if category_name == '' -%}{% continue %}{% endif %}
    {%- assign required_list = '' | split: '|' -%}
    {%- assign optional_list = '' | split: '|' -%}

    {%- for measurement_line in measurement_map_lines -%}
      {%- assign measurement_line = measurement_line | strip -%}
      {%- if measurement_line == '' -%}{% continue %}{% endif %}
      {%- assign parts = measurement_line | split: ':' -%}
      {%- assign measurement_label = parts[0] | strip -%}
      {%- if measurement_label == '' -%}{% continue %}{% endif %}
      {%- assign categories_part = '' -%}
      {%- if parts.size > 1 -%}
        {%- assign categories_part = parts[1] -%}
      {%- endif -%}
      {%- assign category_tokens = categories_part | split: ',' -%}
      {%- for token in category_tokens -%}
        {%- assign token_clean = token | strip -%}
        {%- if token_clean == '' -%}{% continue %}{% endif %}
        {%- assign base_category = token_clean | remove: '*' | strip -%}
        {%- if base_category == category_name -%}
          {%- assign measurement_entry = measurement_label | split: '__split__' -%}
          {%- if base_category != token_clean -%}
            {%- assign optional_list = optional_list | concat: measurement_entry -%}
          {%- else -%}
            {%- assign required_list = required_list | concat: measurement_entry -%}
          {%- endif -%}
        {%- endif -%}
      {%- endfor -%}
    {%- endfor -%}

    {%- assign required_string = required_list | uniq | join: '|' -%}
    {%- assign optional_string = optional_list | uniq | join: '|' -%}

    {%- assign harness_match = false -%}
    {%- for harness in harness_categories -%}
      {%- if harness | strip == category_name -%}
        {%- assign harness_match = true -%}
        {%- break -%}
      {%- endif -%}
    {%- endfor -%}

    {%- assign notes_match = false -%}
    {%- for note_category in notes_categories -%}
      {%- if note_category | strip == category_name -%}
        {%- assign notes_match = true -%}
        {%- break -%}
      {%- endif -%}
    {%- endfor -%}

    <button
      type="button"
      class="option-button"
      data-index="{{ forloop.index0 }}"
      data-label="{{ category_name }}"
      data-required="{{ required_string }}"
      data-optional="{{ optional_string }}"
      data-show-harness="{% if harness_match %}true{% else %}false{% endif %}"
      data-show-notes="{% if notes_match %}true{% else %}false{% endif %}"
    >
      {{ category_name }}
    </button>
  {%- endfor -%}
</div>

{%- comment -%} Unit of Measure - First property to indicate measurement unit used {%- endcomment -%}
<input
  type="hidden"
  id="unitOfMeasure"
  name="properties[Unit of Measure]"
  value="Measured in Inches"
  form="product-form-{{ section.id }}"
>

<input type="hidden" id="selectedOption" name="properties[Selected Option]" form="product-form-{{ section.id }}">

{%- comment -%} Custom Order Tagging {%- endcomment -%}
<input
  type="hidden"
  name="properties[{{ order_tag_name }}]"
  value="{{ order_tag_value }}"
  form="product-form-{{ section.id }}"
>

{%- comment -%} Unit Toggle {%- endcomment -%}
<div class="unit-toggle-container">
  <span class="unit-toggle-label">Unit:</span>
  <div class="unit-toggle-buttons">
    <button type="button" class="unit-toggle-button active" data-unit="in">Inches</button>
    <button type="button" class="unit-toggle-button" data-unit="cm">Centimeters</button>
  </div>
</div>

{%- comment -%} Measurement Fields {%- endcomment -%}
<div class="measurements-group" id="measurementsGroup">
  {%- for meas_name in measurement_names -%}
    {%- assign measurement_label = meas_name | strip -%}
    {%- if measurement_label == '' -%}{% continue %}{% endif %}
    {%- assign handle = measurement_label | handleize -%}
    <div
      class="measurement-field"
      id="measurement-{{ handle }}"
      data-measurement="{{ measurement_label }}"
    >
      <label for="{{ handle }}-in">{{ measurement_label }}</label>
      <input
        type="number"
        inputmode="decimal"
        autocomplete="off"
        id="{{ handle }}-in"
        name="properties[{{ measurement_label }} (in)]"
        form="product-form-{{ section.id }}"
        class="measurement-input measurement-in"
        data-measurement="{{ measurement_label }}"
        placeholder="0.000"
      >
      <input
        type="number"
        inputmode="decimal"
        autocomplete="off"
        id="{{ handle }}-cm"
        name="properties[{{ measurement_label }} (cm)]"
        form="product-form-{{ section.id }}"
        class="measurement-input measurement-cm"
        data-measurement="{{ measurement_label }}"
        placeholder="0.000"
        style="display: none;"
      >
    </div>
  {%- endfor -%}
</div>

{%- comment -%} Harness Details Section {%- endcomment -%}
<div class="conditional-section" id="harness-details">
  <label>Leather Color</label>
  <select name="properties[Leather Color]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for color in leather_colors -%}
      <option>{{ color }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Leather Color - Text]"
    class="custom-text"
    placeholder="Enter custom color"
    form="product-form-{{ section.id }}"
  >

  <label>Left Front Plate</label>
  <select name="properties[Left Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in left_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Left Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Right Front Plate</label>
  <select name="properties[Right Front Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in right_front_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Right Front Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Back Plate</label>
  <select name="properties[Back Plate]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for plate in back_plates -%}
      <option>{{ plate }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Back Plate - Text]"
    class="custom-text"
    placeholder="Enter custom plate"
    form="product-form-{{ section.id }}"
  >

  <label>Long Sliders</label>
  <select name="properties[Long Sliders]" form="product-form-{{ section.id }}">
    <option value="">Select one</option>
    {%- for slider in long_sliders -%}
      <option>{{ slider }}</option>
    {%- endfor -%}
  </select>
  <input
    type="text"
    name="properties[Long Sliders - Text]"
    class="custom-text"
    placeholder="Enter custom sliders"
    form="product-form-{{ section.id }}"
  >

  <div>
    <button type="button" class="custom-toggle-button" onclick="toggleCustomFields()">
      Don't see a color listed? Click here
    </button>
  </div>
</div>

{%- comment -%} Notes Section {%- endcomment -%}
<div class="conditional-section" id="notes-section">
  <label>Notes</label>
  <textarea
    name="properties[Notes]"
    placeholder="Enter your notes here"
    form="product-form-{{ section.id }}"
  ></textarea>
  <label>Event (Optional)</label>
  <textarea
    name="properties[Event (Optional)]"
    placeholder="Event name or details"
    form="product-form-{{ section.id }}"
  ></textarea>
</div>

<script>
  (function () {
    'use strict';

    const optionButtons = Array.from(document.querySelectorAll('.option-button'));
    const measurementFields = Array.from(document.querySelectorAll('.measurement-field'));
    const measurementNames = measurementFields.map((field) => field.dataset.measurement);

    const categoryConfigs = {};
    const harnessDetailCategories = [];
    const notesSectionCategories = [];

    optionButtons.forEach((button) => {
      const categoryName = button.dataset.label;
      const requiredList = (button.dataset.required || '').split('|').filter(Boolean);
      const optionalList = (button.dataset.optional || '').split('|').filter(Boolean);
      categoryConfigs[categoryName] = {
        required: requiredList,
        optional: optionalList,
      };
      if (button.dataset.showHarness === 'true') {
        harnessDetailCategories.push(categoryName);
      }
      if (button.dataset.showNotes === 'true') {
        notesSectionCategories.push(categoryName);
      }
    });

    const measurements = {};
    measurementNames.forEach((measName) => {
      const categoryInfo = {};
      Object.entries(categoryConfigs).forEach(([categoryName, categoryConfig]) => {
        if (categoryConfig.required.includes(measName)) {
          categoryInfo[categoryName] = { included: true, required: true };
        } else if (categoryConfig.optional.includes(measName)) {
          categoryInfo[categoryName] = { included: true, required: false };
        }
      });
      measurements[measName] = { categories: categoryInfo };
    });

    const config = {
      measurements,
      categories: {
        harness_details: harnessDetailCategories,
        notes_section: notesSectionCategories,
      },
    };

    const INCH_TO_CM = 2.54;
    const CM_TO_INCH = 1 / 2.54;
    const PRECISION = 3;

    let currentUnit = 'in';
    let selectedCategory = null;
    const measurementValues = new Map();
    let isSyncingValues = false;
    let hasInteractedWithForm = false;

    const measurementInputs = document.querySelectorAll('.measurement-input');
    const selectedInput = document.getElementById('selectedOption');
    const harnessSection = document.getElementById('harness-details');
    const notesSection = document.getElementById('notes-section');
    const unitToggleButtons = document.querySelectorAll('.unit-toggle-button');

    const productFormSelectors = [
      '#product-form-{{ section.id }}',
      'form[action*="/cart/add"]',
      'form[id^="product-form"]',
    ];
    let productForm = null;
    for (const selector of productFormSelectors) {
      const formCandidate = document.querySelector(selector);
      if (formCandidate) {
        productForm = formCandidate;
        break;
      }
    }

    const unitOfMeasureInput = document.getElementById('unitOfMeasure');
    const harnessSelects = document.querySelectorAll('#harness-details select');
    const harnessCustomTexts = document.querySelectorAll('#harness-details .custom-text');

    const buttonId = 'ProductSubmitButton-{{ section.id }}';
    let addToCartButton = null;
    let addToCartButtonWarningLogged = false;
    let addToCartButtonListenerAttached = false;
    let resetAfterAddToCartPending = false;

    function resolveAddToCartButton() {
      if (addToCartButton && document.body.contains(addToCartButton)) {
        return addToCartButton;
      }

      const buttonSelectors = [
        `#${buttonId}`,
        `#product-form-{{ section.id }} button[type="submit"]`,
        `#product-form-{{ section.id }} button[name="add"]`,
        'form[action*="/cart/add"] button[type="submit"]',
        'form[action*="/cart/add"] button[name="add"]',
        'button[name="add"][type="submit"]',
      ];

      for (const selector of buttonSelectors) {
        const candidate = document.querySelector(selector);
        if (candidate) {
          addToCartButton = candidate;
          if (!addToCartButtonListenerAttached) {
            addToCartButton.addEventListener('click', function () {
              resetAfterAddToCartPending = true;
            });
            addToCartButtonListenerAttached = true;
          }
          return addToCartButton;
        }
      }

      if (!addToCartButtonWarningLogged) {
        console.warn('Could not find add to cart button with ID:', buttonId);
        addToCartButtonWarningLogged = true;
      }

      return null;
    }

    function updateBannerEditingState(isEditing) {
      const eventName = isEditing ? 'custom-order:editing' : 'custom-order:editing-stop';
      try {
        window.dispatchEvent(new CustomEvent(eventName));
      } catch (error) {
        console.warn('Unable to dispatch banner editing event:', error);
      }
      if (window.CustomOrderBanner && typeof window.CustomOrderBanner.notifyEditing === 'function') {
        window.CustomOrderBanner.notifyEditing(isEditing);
      }
    }

    function flagFormInteraction() {
      if (hasInteractedWithForm) return;
      hasInteractedWithForm = true;
      updateBannerEditingState(true);
    }

    function formatValue(value) {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return '';
      }
      return Number(value).toFixed(PRECISION);
    }

    function parseValue(raw) {
      if (typeof raw !== 'string') return NaN;
      const trimmed = raw.trim();
      if (trimmed === '') return NaN;
      const parsed = Number(trimmed);
      return Number.isFinite(parsed) ? parsed : NaN;
    }

    function hasValidNumber(input) {
      if (!input) return false;
      return Number.isFinite(parseValue(input.value));
    }

    function clearMeasurementField(field) {
      const inInput = field.querySelector('.measurement-in');
      const cmInput = field.querySelector('.measurement-cm');
      if (inInput) inInput.value = '';
      if (cmInput) cmInput.value = '';
      measurementValues.delete(field.dataset.measurement);
    }

    function updateMeasurementVisibility() {
      measurementFields.forEach((field) => {
        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');
        if (!inInput || !cmInput) return;
        if (currentUnit === 'in') {
          inInput.style.display = 'block';
          cmInput.style.display = 'none';
        } else {
          inInput.style.display = 'none';
          cmInput.style.display = 'block';
        }
      });
    }

    function syncMeasurementValues(measName, sourceUnit, numericValue) {
      const field = document.querySelector(`.measurement-field[data-measurement="${measName}"]`);
      if (!field) return;
      const inInput = field.querySelector('.measurement-in');
      const cmInput = field.querySelector('.measurement-cm');
      if (!inInput || !cmInput) return;

      if (isSyncingValues) return;
      isSyncingValues = true;

      if (sourceUnit === 'in') {
        if (inInput.value !== formatValue(numericValue)) {
          inInput.value = formatValue(numericValue);
        }
        const converted = numericValue * INCH_TO_CM;
        cmInput.value = formatValue(converted);
        measurementValues.set(measName, { in: numericValue, cm: converted });
      } else {
        if (cmInput.value !== formatValue(numericValue)) {
          cmInput.value = formatValue(numericValue);
        }
        const converted = numericValue * CM_TO_INCH;
        inInput.value = formatValue(converted);
        measurementValues.set(measName, { in: converted, cm: numericValue });
      }

      isSyncingValues = false;
    }

    function updateMeasurementsForCategory(category) {
      measurementFields.forEach((field) => {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];
        const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[category] : null;

        if (categoryInfo && categoryInfo.included) {
          field.classList.add('active');
        } else {
          field.classList.remove('active');
          clearMeasurementField(field);
        }
      });
    }

    function validateRequiredFields() {
      if (!selectedCategory || !config.measurements) return false;

      const activeFields = document.querySelectorAll('.measurement-field.active');
      for (const field of activeFields) {
        const measName = field.dataset.measurement;
        const measConfig = config.measurements[measName];
        if (!measConfig) continue;

        const categoryInfo = measConfig.categories ? measConfig.categories[selectedCategory] : null;
        if (!categoryInfo || !categoryInfo.required) continue;

        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');
        const hasValue = hasValidNumber(inInput) || hasValidNumber(cmInput);
        if (!hasValue) {
          return false;
        }
      }

      if (harnessSection && harnessSection.classList.contains('active')) {
        const harnessFields = [
          'properties[Leather Color]',
          'properties[Left Front Plate]',
          'properties[Right Front Plate]',
          'properties[Back Plate]',
          'properties[Long Sliders]',
        ];

        for (const fieldName of harnessFields) {
          const select = document.querySelector(`select[name="${fieldName}"]`);
          if (!select) continue;
          const selectedOption = select.options[select.selectedIndex];
          const hasSelectValue =
            selectedOption &&
            selectedOption.value !== '' &&
            selectedOption.value !== null &&
            selectedOption.value !== 'Select one';

          const customTextName = fieldName.replace(']', ' - Text]');
          const customText = document.querySelector(`input[name="${customTextName}"]`);
          const hasCustomText = customText && customText.value && customText.value.trim() !== '';

          if (!hasSelectValue && !hasCustomText) {
            return false;
          }
        }
      }

      return true;
    }

    function updateAddToCartButton() {
      const button = resolveAddToCartButton();
      if (!button) return;

      const isValid = validateRequiredFields();
      if (!isValid) {
        button.disabled = true;
        button.style.opacity = '0.5';
        button.setAttribute('disabled', 'disabled');
        button.setAttribute('aria-disabled', 'true');
        button.title = 'Please select a category and fill all required measurements';
      } else {
        button.disabled = false;
        button.style.opacity = '1';
        button.removeAttribute('disabled');
        button.removeAttribute('aria-disabled');
        button.removeAttribute('title');
      }
    }

    function updateSectionVisibility(category) {
      if (harnessSection) {
        const showHarness =
          config.categories && config.categories.harness_details
            ? config.categories.harness_details.includes(category)
            : false;
        harnessSection.classList.toggle('active', showHarness);
      }
      if (notesSection) {
        const showNotes =
          config.categories && config.categories.notes_section
            ? config.categories.notes_section.includes(category) || category === 'Other'
            : category === 'Other';
        notesSection.classList.toggle('active', showNotes);
      }

      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });
    }

    function updateMeasurementOnUnitChange() {
      const activeFields = document.querySelectorAll('.measurement-field.active');
      activeFields.forEach((field) => {
        const measName = field.dataset.measurement;
        const inInput = field.querySelector('.measurement-in');
        const cmInput = field.querySelector('.measurement-cm');

        if (!inInput || !cmInput) return;

        if (currentUnit === 'in') {
          const cmValue = parseValue(cmInput.value);
          if (Number.isFinite(cmValue)) {
            syncMeasurementValues(measName, 'cm', cmValue);
          }
        } else {
          const inValue = parseValue(inInput.value);
          if (Number.isFinite(inValue)) {
            syncMeasurementValues(measName, 'in', inValue);
          }
        }
      });

      updateMeasurementVisibility();
      updateAddToCartButton();
    }

    function initialize() {
      hasInteractedWithForm = false;
      updateBannerEditingState(false);
      resetAfterAddToCartPending = false;

      if (unitOfMeasureInput) {
        unitOfMeasureInput.value = 'Measured in Inches';
      }

      optionButtons.forEach((btn) => btn.classList.remove('selected'));
      if (selectedInput) selectedInput.value = '';
      selectedCategory = null;

      if (harnessSection) harnessSection.classList.remove('active');
      if (notesSection) notesSection.classList.remove('active');

      measurementFields.forEach((field) => {
        clearMeasurementField(field);
        field.classList.remove('active');
      });

      document.querySelectorAll('.custom-text').forEach((el) => {
        el.style.display = 'none';
      });

      currentUnit = 'in';
      unitToggleButtons.forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.unit === 'in');
      });
      updateMeasurementVisibility();

      measurementValues.clear();

      if (optionButtons.length > 0) {
        const firstButton = optionButtons[0];
        firstButton.classList.add('selected');
        selectedCategory = firstButton.dataset.label;
        if (selectedInput) selectedInput.value = selectedCategory;
        updateSectionVisibility(selectedCategory);
        updateMeasurementsForCategory(selectedCategory);
      }

      const button = resolveAddToCartButton();
      if (button) {
        button.disabled = true;
        button.style.opacity = '0.5';
      }
      updateAddToCartButton();
    }

    optionButtons.forEach((button) => {
      button.addEventListener('click', function () {
        flagFormInteraction();
        optionButtons.forEach((btn) => btn.classList.remove('selected'));
        this.classList.add('selected');
        selectedCategory = this.dataset.label;
        if (selectedInput) selectedInput.value = selectedCategory;

        updateSectionVisibility(selectedCategory);
        updateMeasurementsForCategory(selectedCategory);
        updateMeasurementOnUnitChange();
        updateAddToCartButton();
      });
    });

    unitToggleButtons.forEach((button) => {
      button.addEventListener('click', function () {
        flagFormInteraction();
        currentUnit = this.dataset.unit;
        unitToggleButtons.forEach((btn) => {
          btn.classList.toggle('active', btn.dataset.unit === currentUnit);
        });

        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        updateMeasurementOnUnitChange();
      });
    });

    measurementInputs.forEach((input) => {
      input.addEventListener('input', function () {
        flagFormInteraction();
        updateAddToCartButton();
      });

      function normalizeMeasurementValue() {
        const field = input.closest('.measurement-field');
        if (!field) return;
        const measName = field.dataset.measurement;
        const unit = input.classList.contains('measurement-in') ? 'in' : 'cm';
        const numericValue = parseValue(input.value);

        if (Number.isFinite(numericValue)) {
          syncMeasurementValues(measName, unit, numericValue);
        } else if (!isSyncingValues) {
          const targetInput =
            unit === 'in' ? field.querySelector('.measurement-cm') : field.querySelector('.measurement-in');
          if (targetInput) {
            targetInput.value = '';
          }
          measurementValues.delete(measName);
        }
        updateAddToCartButton();
      }

      input.addEventListener('blur', normalizeMeasurementValue);
      input.addEventListener('change', normalizeMeasurementValue);
    });

    harnessSelects.forEach((select) => {
      select.addEventListener('change', updateAddToCartButton);
      select.addEventListener('change', flagFormInteraction);
    });

    harnessCustomTexts.forEach((input) => {
      input.addEventListener('input', function () {
        flagFormInteraction();
        updateAddToCartButton();
      });
    });

    if (productForm) {
      productForm.addEventListener('submit', function (event) {
        if (!validateRequiredFields()) {
          event.preventDefault();
          alert('Please select a category and fill all required measurements.');
          resetAfterAddToCartPending = false;
          return false;
        }

        if (unitOfMeasureInput) {
          const unitValue = currentUnit === 'in' ? 'Measured in Inches' : 'Measured in Centimeters';
          unitOfMeasureInput.value = unitValue;
          unitOfMeasureInput.setAttribute('value', unitValue);
        }

        document.querySelectorAll('.measurement-field.active').forEach((field) => {
          const measName = field.dataset.measurement;
          const inInput = field.querySelector('.measurement-in');
          const cmInput = field.querySelector('.measurement-cm');
          const inValue = parseValue(inInput ? inInput.value : '');
          const cmValue = parseValue(cmInput ? cmInput.value : '');

          if (Number.isFinite(inValue) && !Number.isFinite(cmValue)) {
            syncMeasurementValues(measName, 'in', inValue);
          } else if (Number.isFinite(cmValue) && !Number.isFinite(inValue)) {
            syncMeasurementValues(measName, 'cm', cmValue);
          }
        });

        if (selectedCategory && config.measurements) {
          const measurementInputsForSubmit = this.querySelectorAll('input[name^="properties["]');
          measurementInputsForSubmit.forEach((input) => {
            const name = input.getAttribute('name');
            if (!name || (!name.includes('(in)') && !name.includes('(cm)'))) return;

            const match = name.match(/properties\[(.+?)\s+\(in\)\]|properties\[(.+?)\s+\(cm\)\]/);
            if (!match) return;

            const measName = match[1] || match[2];
            const measConfig = config.measurements[measName];
            const categoryInfo = measConfig && measConfig.categories ? measConfig.categories[selectedCategory] : null;
            const isIncluded = categoryInfo && categoryInfo.included === true;
            const value = input.value && input.value.trim() !== '' ? input.value : '';

            if (!isIncluded || value === '') {
              input.removeAttribute('name');
              input.setAttribute('data-removed', 'true');
            }
          });
        }

        resetAfterAddToCartPending = true;
        hasInteractedWithForm = false;
        updateBannerEditingState(false);
      });
    }

    function delayedInitialize() {
      initialize();
      updateAddToCartButton();
    }

    window.addEventListener('pageshow', function () {
      initialize();
      updateAddToCartButton();
    });

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', delayedInitialize);
    } else {
      delayedInitialize();
    }

    document.addEventListener('cart:updated', function () {
      hasInteractedWithForm = false;
      updateBannerEditingState(false);
      if (resetAfterAddToCartPending) {
        initialize();
        updateAddToCartButton();
        resetAfterAddToCartPending = false;
      }
    });
  })();

  function toggleCustomFields() {
    document.querySelectorAll('.custom-text').forEach((el) => {
      el.style.display = 'block';
    });
  }
</script>
